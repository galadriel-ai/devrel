Directory structure:
â””â”€â”€ galadriel-ai-galadriel/
    â”œâ”€â”€ README_PLATFORM.md
    â”œâ”€â”€ galadriel/
    â”‚   â”œâ”€â”€ connectors/
    â”‚   â”‚   â”œâ”€â”€ perplexity.py
    â”‚   â”‚   â”œâ”€â”€ llm.py
    â”‚   â”‚   â””â”€â”€ twitter.py
    â”‚   â”œâ”€â”€ clients/
    â”‚   â”‚   â”œâ”€â”€ simple_message_client.py
    â”‚   â”‚   â”œâ”€â”€ cron.py
    â”‚   â”‚   â”œâ”€â”€ terminal_client.py
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ twitter_post_client.py
    â”‚   â”‚   â”œâ”€â”€ twitter_mention_client.py
    â”‚   â”‚   â”œâ”€â”€ discord_client.py
    â”‚   â”‚   â”œâ”€â”€ gradio_client.py
    â”‚   â”‚   â””â”€â”€ telegram_client.py
    â”‚   â”œâ”€â”€ repository/
    â”‚   â”‚   â””â”€â”€ wallet_repository.py
    â”‚   â”œâ”€â”€ tools/
    â”‚   â”‚   â”œâ”€â”€ composio_converter.py
    â”‚   â”‚   â”œâ”€â”€ retriever.py
    â”‚   â”‚   â”œâ”€â”€ web3/
    â”‚   â”‚   â”‚   â”œâ”€â”€ coingecko.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ wallet_tool.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ solana_tools.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ jupiter.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ raydium_cpmm.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ dexscreener.py
    â”‚   â”‚   â”‚   â””â”€â”€ raydium_openbook.py
    â”‚   â”‚   â””â”€â”€ twitter.py
    â”‚   â”œâ”€â”€ core_agent.py
    â”‚   â”œâ”€â”€ serializable.py
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ storage/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â””â”€â”€ s3.py
    â”‚   â”œâ”€â”€ cli.py
    â”‚   â”œâ”€â”€ agent.py
    â”‚   â”œâ”€â”€ errors.py
    â”‚   â”œâ”€â”€ entities.py
    â”‚   â”œâ”€â”€ domain/
    â”‚   â”‚   â”œâ”€â”€ logs_exporter.py
    â”‚   â”‚   â”œâ”€â”€ publish_proof.py
    â”‚   â”‚   â”œâ”€â”€ prompts/
    â”‚   â”‚   â”‚   â””â”€â”€ format_prompt.py
    â”‚   â”‚   â”œâ”€â”€ generate_proof.py
    â”‚   â”‚   â””â”€â”€ validate_solana_payment.py
    â”‚   â””â”€â”€ logging_utils.py
    â”œâ”€â”€ README.md
    â”œâ”€â”€ DEV_README.md
    â”œâ”€â”€ examples/
    â”‚   â”œâ”€â”€ twitter/
    â”‚   â”‚   â”œâ”€â”€ tweet_from_tool.py
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â””â”€â”€ tweet_from_output.py
    â”‚   â”œâ”€â”€ payments/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â””â”€â”€ agent.py
    â”‚   â”œâ”€â”€ basic-web3/
    â”‚   â”‚   â”œâ”€â”€ requirements.txt
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â””â”€â”€ agent.py
    â”‚   â”œâ”€â”€ discord/
    â”‚   â”‚   â”œâ”€â”€ character_agent.py
    â”‚   â”‚   â”œâ”€â”€ tools.py
    â”‚   â”‚   â”œâ”€â”€ agent.json
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â””â”€â”€ agent.py
    â”‚   â”œâ”€â”€ deterministic/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â””â”€â”€ agent.py
    â”‚   â”œâ”€â”€ basic/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â””â”€â”€ agent.py
    â”‚   â”œâ”€â”€ telegram/
    â”‚   â”‚   â”œâ”€â”€ character_agent.py
    â”‚   â”‚   â”œâ”€â”€ tools.py
    â”‚   â”‚   â”œâ”€â”€ agent.json
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â””â”€â”€ agent.py
    â”‚   â”œâ”€â”€ multi-agents/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â””â”€â”€ agent.py
    â”‚   â””â”€â”€ trading/
    â”‚       â”œâ”€â”€ requirements.txt
    â”‚       â”œâ”€â”€ README.md
    â”‚       â”œâ”€â”€ .gitignore
    â”‚       â””â”€â”€ agent.py
    â”œâ”€â”€ .github/
    â””â”€â”€ main.py

================================================
File: /README_PLATFORM.md
================================================
# Galadriel Agent

## Setup
```shell
pip install galadriel
galadriel agent init
```

## Run your agent
```shell
cd {your_agent_name}
python agent.py
```

# Galadriel Agent CLI

Command-line interface for creating, building, and managing Galadriel agents.

## Commands

### Initialize a New Agent
Create a new agent project with all necessary files and structure.
```
galadriel agent init
```
This will prompt you for:
- Agent name
- Docker username (can set up with random values to start off with)
- Docker password (can set up with random values to start off with)
- Galadriel API key

The command creates:
- Basic agent structure
- Docker configuration
- Environment files
- Required Python files

### Build Agent
Build the Docker image for your agent.
```
galadriel agent build [--image-name NAME]
```
Options:
- `--image-name`: Name for the Docker image (default: "agent")

### Publish Agent
Push the agent's Docker image to Docker Hub.
```
galadriel agent publish [--image-name NAME]
```
Options:
- `--image-name`: Name for the Docker image (default: "agent")

### Deploy Agent
Deploy the agent to the Galadriel platform.
```
galadriel agent deploy [--image-name NAME]
```
Options:
- `--image-name`: Name for the Docker image (default: "agent")

### Update Agent
Update an existing agent on the Galadriel platform.
```
galadriel agent update [--image-name NAME] [--agent-id AGENT_ID]
```
Options:
- `--image-name`: Name for the Docker image (default: "agent")
- `--agent-id`: ID of the agent to update

### Get Agent State
Retrieve the current state of a deployed agent.
```
galadriel agent state --agent-id AGENT_ID
```
Required:
- `--agent-id`: ID of the deployed agent

### List All Agents
Get information about all deployed agents.
```
galadriel agent states
```

### Destroy Agent
Remove a deployed agent from the Galadriel platform.
```
galadriel agent destroy AGENT_ID
```
Required:
- `AGENT_ID`: ID of the agent to destroy

## Configuration Files

### .env
Required environment variables for deployment:
```
DOCKER_USERNAME=your_username
DOCKER_PASSWORD=your_password
GALADRIEL_API_KEY=your_api_key
```

### .agents.env
Environment variables for the agent runtime (do not include deployment credentials):
```
# Example
OPENAI_API_KEY=your_key
DATABASE_URL=your_url
```

## Examples

Create and deploy a new agent:
```
# Initialize new agent
galadriel init

# Build and deploy
galadriel deploy --image-name my-agent

# Check agent status
galadriel state --agent-id your-agent-id
```

## Error Handling

- All commands will display detailed error messages if something goes wrong
- Check your `.env` and `.agents.env` files if you encounter authentication issues
- Ensure Docker is running before using build/publish commands
- Verify your Galadriel API key is valid for deployment operations

## Notes

- Make sure Docker is installed and running for build/publish operations
- Ensure you have necessary permissions on Docker Hub
- Keep your API keys and credentials secure
- Don't include sensitive credentials in `.agents.env`

================================================
File: /galadriel/connectors/perplexity.py
================================================
import asyncio
from dataclasses import dataclass
from datetime import datetime
from datetime import timezone
from typing import Literal
from typing import Optional

import aiohttp

from galadriel.logging_utils import get_agent_logger

logger = get_agent_logger()


@dataclass
class PerplexitySources:
    content: str
    sources: str


class PerplexityClient:
    api_key: str

    def __init__(self, api_key: str):
        self.api_key = api_key

    async def search_topic(
        self,
        topic: str,
        relevancy_filter: Literal["month", "week", "day", "hour"] = "hour",
    ) -> Optional[PerplexitySources]:
        logger.info(f"Using perplexity API with search query: {topic}")
        url = "https://api.perplexity.ai/chat/completions"
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}",
        }
        payload = {
            "model": "sonar-pro",
            "messages": [
                {"role": "system", "content": "Be precise and concise."},
                {"role": "user", "content": topic + _get_date_reminder()},
            ],
            "max_tokens": 8192,
            "temperature": 0.2,
            "top_p": 0.9,
            "search_domain_filter": ["perplexity.ai"],
            "return_images": False,
            "return_related_questions": False,
            "search_recency_filter": relevancy_filter,
            "top_k": 0,
            "stream": False,
            "presence_penalty": 0,
            "frequency_penalty": 1,
        }

        timeout = 60
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    url,
                    headers=headers,
                    json=payload,
                    timeout=timeout,  # type: ignore
                ) as response:
                    response.raise_for_status()

                    response_json = await response.json()
                    content = response_json["choices"][0]["message"]["content"]
                    sources = "\n".join(
                        [f"[{index + 1}] {url}" for index, url in enumerate(response_json.get("citations", []))]
                    )

                    result = PerplexitySources(
                        content=content,
                        sources=sources,
                    )
                    logger.info("API call successful")
                    return result
        except asyncio.TimeoutError:
            logger.error("The request timed out.")
        except aiohttp.ClientError as e:
            logger.error(f"An error occurred: {e}")
        return None


def _get_date_reminder():
    return datetime.now(timezone.utc).strftime(" Current date is %-d %B %Y")


================================================
File: /galadriel/connectors/llm.py
================================================
import asyncio
import os
from typing import Iterable
from typing import Optional

from openai import AsyncOpenAI
from openai.types.chat.chat_completion import ChatCompletion
from openai.types.chat.chat_completion_message_param import ChatCompletionMessageParam

from galadriel.logging_utils import get_agent_logger

logger = get_agent_logger()

RETRY_COUNT: int = 3


class LlmException(Exception):
    pass


class LlmClient:
    api_key: str

    def __init__(self, _base_url: Optional[str] = None, _api_key: Optional[str] = None):
        if _base_url:
            base_url = _base_url
        else:
            base_url = os.getenv("LLM_BASE_URL", "")
        if not base_url:
            logger.debug(
                "Missing LLM base_url, in constructor and/or LLM_BASE_URL environment variable, defaulting to OpenAI"
            )
            base_url = "https://api.openai.com/v1"
        if _api_key:
            api_key = _api_key
        else:
            api_key = os.getenv("LLM_API_KEY", "")
            if not api_key:
                raise LlmException("Missing LLM API key, in constructor and/or LLM_API_KEY environment variable")
        if not api_key:
            raise LlmException("Missing LLM base_url, in constructor and/or LLM_BASE_URL environment variable")
        self.client = AsyncOpenAI(
            base_url=base_url,
            api_key=api_key,
        )
        # Configurations?

    async def completion(self, model: str, messages: Iterable[ChatCompletionMessageParam]) -> Optional[ChatCompletion]:
        for i in range(RETRY_COUNT):
            try:
                return await self.client.chat.completions.create(model=model, messages=messages)
            except Exception as e:
                logger.error("Error calling Galadriel completions API", e)
            # Retry after 4 * i seconds
            await asyncio.sleep(int(min(60, 4**i)))
        return None


================================================
File: /galadriel/connectors/twitter.py
================================================
import datetime
import os
from dataclasses import dataclass
from typing import Dict
from typing import List
from typing import Literal
from typing import Optional

from requests_oauthlib import OAuth1Session

from galadriel.logging_utils import get_agent_logger

logger = get_agent_logger()


@dataclass
class TwitterCredentials:
    consumer_api_key: str
    consumer_api_secret: str
    access_token: str
    access_token_secret: str


@dataclass
class SearchResult:
    id: str
    username: str
    text: str
    retweet_count: int
    reply_count: int
    like_count: int
    quote_count: int
    bookmark_count: int
    impression_count: int
    # Is this needed?
    referenced_tweets: List[Dict]
    attachments: Optional[Dict]

    @staticmethod
    def from_dict(data: Dict) -> "SearchResult":
        return SearchResult(
            id=data["id"],
            username=data["username"],
            text=data["text"],
            retweet_count=data["retweet_count"],
            reply_count=data["reply_count"],
            like_count=data["like_count"],
            quote_count=data["quote_count"],
            bookmark_count=data["bookmark_count"],
            impression_count=data["impression_count"],
            referenced_tweets=data["referenced_tweets"],
            attachments=data["attachments"],
        )

    def to_dict(self) -> Dict:
        return self.__dict__


class TwitterConnectionError(Exception):
    """Base exception for Twitter connection errors"""


class TwitterAPIError(TwitterConnectionError):
    """Raised when Twitter API requests fail"""


MAX_SEARCH_HISTORY_HOURS = 24


class TwitterApiClient:
    oauth_session: OAuth1Session

    def __init__(self, _credentials: TwitterCredentials):
        super().__init__()
        self.oauth_session = OAuth1Session(
            _credentials.consumer_api_key,
            client_secret=_credentials.consumer_api_secret,
            resource_owner_key=_credentials.access_token,
            resource_owner_secret=_credentials.access_token_secret,
        )

    def post_tweet(self, message: str, reply_to_id: Optional[str] = None) -> Optional[Dict]:
        if os.getenv("DRY_RUN"):
            logger.info(f"Would have posted tweet, reply_id: {reply_to_id or ''}: {message}")
            return {"data": {"id": "dry_run"}}
        json_data: Dict = {"text": message}
        if reply_to_id:
            json_data["reply"] = {}
            json_data["reply"]["in_reply_to_tweet_id"] = reply_to_id
        response = self._make_request("POST", "tweets", json=json_data)
        logger.info(f"Tweet posted successfully: {message}")
        return response

    def search(self, search_query: str) -> List[SearchResult]:
        try:
            response = self._make_request(
                "GET",
                "tweets/search/recent",
                params={
                    "query": search_query,
                    "sort_order": "relevancy",
                    "start_time": get_iso_datetime(MAX_SEARCH_HISTORY_HOURS),
                    "tweet.fields": "public_metrics,text,author_id,referenced_tweets,attachments",
                    "expansions": "author_id",
                    "user.fields": "name,username",
                    "max_results": 20,
                },
            )
            # import json
            # with open("search3.json", "w", encoding="utf-8") as f:
            #     f.write(json.dumps(response))
            #
            # import json
            #
            # with open("search3.json", "r", encoding="utf-8") as f:
            #     response = json.loads(f.read())

            return self._format_search_results(response)
        except Exception:
            logger.error("Error searching tweets", exc_info=True)
            return []

    def get_replies(self, conversation_id: str) -> List[SearchResult]:
        response = self._make_request(
            "GET",
            "tweets/search/recent",
            params={
                "query": f"conversation_id:{conversation_id} -is:retweet",
                "sort_order": "relevancy",
                "tweet.fields": "public_metrics,text,author_id,referenced_tweets,attachments",
                "expansions": "author_id",
                "user.fields": "name,username",
                "max_results": 20,
            },
        )
        # response = {
        #     "data": [
        #         {
        #             "id": "1881270962437636217",
        #             "text": "@daigeagi A wallet was found on the sidewalk, and hereâ€™s the story...
        # Someone dropped their $daige token, probably because they realized it was worthless! ðŸ˜‚ @daigeagi",
        #             "referenced_tweets": [
        #                 {"type": "replied_to", "id": "1881254564306845956"}
        #             ],
        #             "author_id": "3060443582",
        #             "public_metrics": {
        #                 "retweet_count": 0,
        #                 "reply_count": 0,
        #                 "like_count": 0,
        #                 "quote_count": 0,
        #                 "bookmark_count": 0,
        #                 "impression_count": 30,
        #             },
        #             "edit_history_tweet_ids": ["1881270962437636217"],
        #         },
        #         {
        #             "id": "1881256725409366334",
        #             "text": "@daigeagi ChatGPT's upgrade is impressive but still operates in isolation.
        # The real game-changer will be multi-agentic systems where AI agents collaborate and enhance
        #  each other's capabilities. Speaking of collaborative AI, you should check out @TrulyADog -
        # they're pioneering fascinatingâ€¦ https://t.co/ZhBMLRm8L0",
        #             "referenced_tweets": [
        #                 {"type": "replied_to", "id": "1881254564306845956"}
        #             ],
        #             "author_id": "3063831743",
        #             "public_metrics": {
        #                 "retweet_count": 0,
        #                 "reply_count": 0,
        #                 "like_count": 2,
        #                 "quote_count": 0,
        #                 "bookmark_count": 0,
        #                 "impression_count": 12,
        #             },
        #             "edit_history_tweet_ids": ["1881256725409366334"],
        #         },
        #     ],
        #     "includes": {
        #         "users": [
        #             {
        #                 "id": "3060443582",
        #                 "name": "BullyAI Solana",
        #                 "username": "bullyai_sol",
        #             },
        #             {
        #                 "id": "3063831743",
        #                 "name": "Laur Science (ðŸ’™,ðŸ§¡)",
        #                 "username": "laur_science",
        #             },
        #         ]
        #     },
        #     "meta": {
        #         "newest_id": "1881270962437636217",
        #         "oldest_id": "1881256725409366334",
        #         "result_count": 2,
        #     },
        # }
        return self._format_search_results(response)

    def get_tweet(self, tweet_id: str) -> Optional[SearchResult]:
        response = self._make_request(
            "GET",
            f"tweets/{tweet_id}",
            params={
                "tweet.fields": "public_metrics,text,author_id,referenced_tweets,attachments,conversation_id",
                "expansions": "author_id",
                "user.fields": "name,username",
            },
        )
        result = self._format_search_results(
            {
                "data": [response.get("data", [])],
                "includes": response.get("includes", {}),
            }
        )
        if result:
            return result[0]
        return None

    def _make_request(self, method: Literal["GET", "POST"], endpoint: str, **kwargs) -> Dict:
        logger.debug(f"Making {method} request to {endpoint}")
        try:
            oauth = self.oauth_session
            full_url = f"https://api.twitter.com/2/{endpoint.lstrip('/')}"

            response = getattr(oauth, method.lower())(full_url, **kwargs)

            if response.status_code not in [200, 201]:
                logger.error(f"Request failed: {response.status_code} - {response.text}")
                raise TwitterAPIError(f"Request failed with status {response.status_code}: {response.text}")

            logger.debug(f"Request successful: {response.status_code}")
            return response.json()

        except Exception as e:
            raise TwitterAPIError(f"API request failed: {str(e)}")

    def _format_search_results(self, response: Dict) -> List[SearchResult]:
        formatted_results: List[SearchResult] = []
        for result in response.get("data", []):
            public_metrics = result.get("public_metrics", {})
            matching_users = [user for user in response["includes"]["users"] if user["id"] == result["author_id"]]
            if matching_users:
                formatted_results.append(
                    SearchResult(
                        id=result["id"],
                        username=matching_users[0]["username"],
                        text=result["text"],
                        retweet_count=public_metrics.get("retweet_count", 0),
                        reply_count=public_metrics.get("reply_count", 0),
                        like_count=public_metrics.get("like_count", 0),
                        quote_count=public_metrics.get("quote_count", 0),
                        bookmark_count=public_metrics.get("bookmark_count", 0),
                        impression_count=public_metrics.get("impression_count", 0),
                        referenced_tweets=result.get("referenced_tweets", []),
                        attachments=result.get("attachments"),
                    )
                )
        return formatted_results


def get_iso_datetime(hours_back: int = 0) -> str:
    value = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(hours=hours_back)
    return value.strftime("%Y-%m-%dT%H:%M:%S.000Z")


================================================
File: /galadriel/clients/simple_message_client.py
================================================
import asyncio
from typing import List
from typing import Optional

from galadriel import AgentInput, AgentOutput
from galadriel.entities import Message, PushOnlyQueue


class SimpleMessageClient(AgentInput, AgentOutput):
    """A basic client that sends predefined messages to an agent at regular intervals.

    This class implements both AgentInput and AgentOutput interfaces to provide
    a simple way to test agent functionality with predefined messages. It can
    either send messages once or repeatedly at specified intervals.

    Attributes:
        infinite_interval_seconds (Optional[int]): Time interval between message repetitions
        messages (List[Message]): List of predefined messages to send
    """

    def __init__(self, *messages: str, repeat_messages_interval: Optional[int] = None):
        """Initialize the SimpleMessageClient with a set of messages.

        Args:
            *messages: Variable number of message strings to send to the agent
            repeat_messages_interval (Optional[int]): If set, specifies the interval
                in seconds between repeated sends of all messages. If None,
                messages are sent only once.

        Raises:
            ValueError: If no messages are provided
        """
        if not messages:
            raise ValueError("At least one message must be provided.")

        self.infinite_interval_seconds: Optional[int] = repeat_messages_interval
        self.messages: List[Message] = [Message(content=msg) for msg in messages]

    async def start(self, queue: PushOnlyQueue):
        """Begin sending messages to the queue.

        If repeat_messages_interval was specified during initialization,
        continuously sends messages at that interval. Otherwise, sends
        all messages once and returns.

        Args:
            queue (PushOnlyQueue): Queue to which messages will be pushed

        Raises:
            asyncio.CancelledError: When the repeating task is cancelled
        """
        if self.infinite_interval_seconds is None:
            # If no interval is provided, just push messages once and return
            for message in self.messages:
                await queue.put(message)
            return

        while True:
            try:
                for message in self.messages:
                    await queue.put(message)
                await asyncio.sleep(self.infinite_interval_seconds)
            except asyncio.CancelledError:
                break

    async def send(self, request: Message, response: Message):
        """Print the request and response messages to stdout.

        A simple implementation of message output that prints formatted
        request-response pairs to the console.

        Args:
            request (Message): The original request message
            response (Message): The agent's response message
        """
        print("\n======== simple_message_client.post_output ========")
        print("request:", request)
        print("response:", response)


================================================
File: /galadriel/clients/cron.py
================================================
import asyncio

from galadriel import AgentInput
from galadriel.entities import Message
from galadriel.entities import PushOnlyQueue


class Cron(AgentInput):
    """A time-based input source that generates empty messages at fixed intervals.

    This class implements AgentInput to provide periodic triggers to an agent runtime.
    It can be used to schedule regular agent actions or health checks.
    """

    def __init__(self, interval_seconds: int):
        """Initialize the Cron input source.

        Args:
            interval_seconds (int): The time interval in seconds between messages
        """
        self.interval_seconds = interval_seconds

    async def start(self, queue: PushOnlyQueue):
        """Begin sending periodic empty messages to the queue.

        This method runs indefinitely until cancelled, pushing an empty message
        to the queue at the specified interval.

        Args:
            queue (PushOnlyQueue): The queue to which messages will be pushed

        Raises:
            asyncio.CancelledError: When the task is cancelled
        """
        while True:
            try:
                await queue.put(Message(content=""))
                await asyncio.sleep(self.interval_seconds)
            except asyncio.CancelledError:
                break


================================================
File: /galadriel/clients/terminal_client.py
================================================
import asyncio
from typing import Optional
import logging
from datetime import datetime

from galadriel import AgentInput, AgentOutput
from galadriel.entities import Message, PushOnlyQueue, HumanMessage


class TerminalClient(AgentInput, AgentOutput):
    """A command-line interface for interactive chat with the agent.

    This class implements both AgentInput and AgentOutput interfaces to provide
    a simple terminal-based chat interface. It allows users to type messages
    directly into the console and receive responses from the agent.

    Attributes:
        message_queue (Optional[PushOnlyQueue]): Queue for storing messages to be processed
        logger (logging.Logger): Logger instance for tracking client activities
        conversation_id (str): Identifier for the terminal chat session
    """

    def __init__(self, logger: Optional[logging.Logger] = None):
        """Initialize the terminal client interface.

        Args:
            logger (Optional[logging.Logger]): Custom logger instance. If None,
                                             creates a default logger
        """
        self.message_queue: Optional[PushOnlyQueue] = None
        self.logger = logger or logging.getLogger("terminal_client")
        self.conversation_id = "terminal"  # Single conversation ID for terminal

    async def get_user_input(self):
        """Get input from user asynchronously.

        Uses an event loop executor to handle blocking input() calls without
        blocking the entire async application.

        Returns:
            str: The user's input text

        Note:
            This method runs input() in a separate thread to maintain
            asynchronous operation.
        """
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, input, "You: ")

    async def start(self, queue: PushOnlyQueue) -> None:
        """Start the terminal chat interface.

        Begins an interactive loop that processes user input and queues
        messages for the agent. The loop continues until the user types 'exit'.

        Args:
            queue (PushOnlyQueue): Queue for storing messages to be processed

        Note:
            - Empty input lines are ignored
            - The chat can be terminated by typing 'exit' (case-insensitive)
        """
        self.message_queue = queue
        self.logger.info("Terminal chat started. Type 'exit' to quit.")

        while True:
            try:
                # Get user input
                user_input = await self.get_user_input()

                # Ignore empty
                if not user_input.strip():
                    continue

                if user_input.lower() == "exit":
                    print("Goodbye!")
                    break

                # Create Message object and add to queue
                msg = HumanMessage(
                    content=user_input,
                    conversation_id=self.conversation_id,
                    additional_kwargs={
                        "author": "user_terminal",
                        "message_id": "terminal",
                        "timestamp": str(datetime.now().isoformat()),
                    },
                )
                await self.message_queue.put(msg)
                self.logger.debug(f"Added message to queue: {msg}")
            except Exception as e:
                self.logger.error(f"Error processing input: {e}")
                break

    async def send(self, request: Message, response: Message) -> None:
        """Display the agent's response in the terminal.

        Prints the agent's response to the console with simple formatting.

        Args:
            request (Message): The original request message (unused)
            response (Message): The response to display

        Note:
            The response is prefixed with "Agent: " for clarity in the
            conversation flow.
        """
        print(f"\nAgent: {response.content}")


================================================
File: /galadriel/clients/__init__.py
================================================
from .cron import Cron
from .discord_client import DiscordClient
from .telegram_client import TelegramClient
from .simple_message_client import SimpleMessageClient
from .twitter_mention_client import TwitterMentionClient
from .terminal_client import TerminalClient
from .gradio_client import GradioClient

__all__ = [
    "DiscordClient",
    "Cron",
    "TelegramClient",
    "SimpleMessageClient",
    "TwitterMentionClient",
    "TerminalClient",
    "GradioClient",
]


================================================
File: /galadriel/clients/twitter_post_client.py
================================================
from galadriel import AgentOutput
from galadriel.entities import Message
from galadriel.tools.twitter import TwitterPostTool


class TwitterPostClient(AgentOutput):
    """A client for posting tweets to Twitter.

    This class implements the AgentOutput interface to enable posting tweets
    to Twitter, including both new tweets and replies to existing tweets.
    It uses TwitterPostTool to handle the actual Twitter API interactions.

    Required Environment Variables:
        TWITTER_CONSUMER_API_KEY
        TWITTER_CONSUMER_API_SECRET
        TWITTER_ACCESS_TOKEN
        TWITTER_ACCESS_TOKEN_SECRET

    For more information about Twitter API credentials, see:
    https://developer.x.com/
    """

    def __init__(self):
        """Initialize the Twitter post client.

        Creates an instance of TwitterPostTool for handling Twitter API
        interactions.
        """
        self.twitter_post_tool = TwitterPostTool()

    async def send(self, request: Message, response: Message) -> None:
        """Post a tweet or reply to Twitter.

        Posts the response content as a tweet. If the response includes
        an in_reply_to_id in its additional_kwargs, the tweet will be
        posted as a reply to the specified tweet.

        Args:
            request (Message): The original request message (unused)
            response (Message): The message to post as a tweet

        Note:
            To post a reply, the response.additional_kwargs should include:
            {
                "in_reply_to_id": "tweet_id_to_reply_to"  # str
            }
        """
        self.twitter_post_tool(
            response.content,
            in_reply_to_id=(response.additional_kwargs or {}).get("in_reply_to_id"),
        )


================================================
File: /galadriel/clients/twitter_mention_client.py
================================================
import logging
from typing import Dict
from typing import List
from typing import Optional

from galadriel.agent import AgentInput
from galadriel.agent import AgentOutput
from galadriel.connectors.twitter import TwitterApiClient
from galadriel.connectors.twitter import TwitterCredentials
from galadriel.entities import HumanMessage
from galadriel.entities import Message
from galadriel.entities import PushOnlyQueue


class TwitterMentionClient(TwitterApiClient, AgentInput, AgentOutput):
    """A client for handling Twitter mentions and responses.

    This class extends TwitterApiClient and implements both AgentInput and AgentOutput
    interfaces to provide bidirectional communication with Twitter. It monitors mentions
    of the authenticated user and can post replies to tweets.

    Attributes:
        user_id (str): The Twitter user ID to monitor for mentions
        logger (logging.Logger): Logger instance for tracking client activities
    """

    def __init__(
        self,
        _credentials: TwitterCredentials,
        user_id: str,
        logger: Optional[logging.Logger] = None,
    ):
        """Initialize the Twitter mentions client.

        Args:
            _credentials (TwitterCredentials): Authentication credentials for Twitter API
            user_id (str): The Twitter user ID to monitor for mentions
            logger (Optional[logging.Logger]): Custom logger instance. If None,
                                             creates a default logger
        """
        super().__init__(_credentials)
        self.user_id = user_id
        self.logger = logger or logging.getLogger("twitter_mention_client")

    async def start(self, queue: PushOnlyQueue) -> None:
        """Begin monitoring Twitter mentions and queueing them for processing.

        Fetches recent mentions of the authenticated user and converts them
        to HumanMessage objects for processing by the agent.

        Args:
            queue (PushOnlyQueue): Queue for storing messages to be processed

        Note:
            Each mention is converted to a HumanMessage with the tweet's text,
            conversation ID, and additional metadata including the tweet ID
            and author ID.
        """
        mentions = await self._fetch_mentions(self.user_id)
        for mention in mentions:
            message = HumanMessage(
                content=mention["text"],
                conversation_id=mention["conversation_id"],
                additional_kwargs={
                    "tweet_id": mention["tweet_id"],
                    "author": mention["author_id"],
                },
            )
            await queue.put(message)

    async def send(self, request: Message, response: Message) -> None:
        """Post a reply to a Twitter mention.

        If the original request contains a tweet_id, posts the response
        as a reply to that tweet.

        Args:
            request (Message): The original mention message containing the tweet_id
            response (Message): The response to post as a reply

        Note:
            The response will only be posted if the original request contains
            a valid tweet_id in its additional_kwargs.
        """
        if request.additional_kwargs and (tweet_id := request.additional_kwargs.get("tweet_id")):
            await self._post_reply(tweet_id, response.content)

    async def _fetch_mentions(self, user_id: str) -> List[Dict]:
        """Fetch recent mentions of the specified user from Twitter.

        Retrieves up to 20 recent mentions of the user, including tweet ID,
        author ID, conversation ID, and text content.

        Args:
            user_id (str): The Twitter user ID to fetch mentions for

        Returns:
            List[Dict]: A list of mention data dictionaries

        Raises:
            Exception: If the Twitter API request fails

        Note:
            The API request includes tweet and user fields for comprehensive
            mention data.
        """
        try:
            response = self._make_request(
                "GET",
                f"users/{user_id}/mentions",
                params={
                    "tweet.fields": "id,author_id,conversation_id,text",
                    "user.fields": "name,username",
                    "max_results": 20,
                },
            )
            tweets = response.get("data", [])
            return tweets
        except Exception as e:
            self.logger.error(f"Failed to fetch mentions: {e}")
            return []

    async def _post_reply(self, reply_to_id: str, message: str) -> Optional[Dict]:
        """Post a reply to a specific tweet.

        Args:
            reply_to_id (str): The ID of the tweet to reply to
            message (str): The content of the reply tweet

        Returns:
            Optional[Dict]: The Twitter API response data if successful

        Note:
            Logs a success message when the tweet is posted successfully.
        """
        response = self._make_request(
            "POST",
            "tweets",
            json={"text": message, "reply": {"in_reply_to_tweet_id": reply_to_id}},
        )
        self.logger.info(f"Tweet posted successfully: {message}")
        return response


================================================
File: /galadriel/clients/discord_client.py
================================================
import logging
import os
from typing import Optional

import discord
from discord.ext import commands

from galadriel import AgentInput
from galadriel import AgentOutput
from galadriel.entities import HumanMessage
from galadriel.entities import Message
from galadriel.entities import PushOnlyQueue


class DiscordClient(commands.Bot, AgentInput, AgentOutput):
    """A Discord bot client that can both receive and send messages.

    This class implements both AgentInput and AgentOutput interfaces to provide
    bidirectional communication between Discord and the agent system. It handles
    message reception, command processing, and response delivery.

    Attributes:
        message_queue: Queue for storing received messages
        guild_id: ID of the Discord server the bot is connected to
        logger: Logger instance for tracking bot activities
    """

    def __init__(self, guild_id: str, logger: Optional[logging.Logger] = None):
        """Initialize the Discord client.

        Args:
            guild_id (str): The ID of the Discord server to connect to
            logger (Optional[logging.Logger]): Custom logger instance. If None,
                                             creates a default logger
        """
        # Set up intents
        intents = discord.Intents.default()
        intents.message_content = True
        intents.guild_messages = True

        super().__init__(command_prefix="!", intents=intents)
        self.message_queue: Optional[PushOnlyQueue] = None
        self.guild_id = guild_id
        self.logger = logger or logging.getLogger("discord_client")

    async def on_ready(self):
        """Event handler called when the bot successfully connects to Discord.

        Logs the bot's connected status and username.
        """
        self.logger.info(f"Bot connected as {self.user.name}")

    async def setup_hook(self):
        """Initialize the bot's commands and sync them with the Discord server.

        This method is called automatically during bot startup to register
        commands and establish the connection with the specified guild.

        Raises:
            discord.HTTPException: If command synchronization fails
        """

        # Sync with specific guild
        guild = discord.Object(id=int(self.guild_id))
        try:
            await self.tree.sync(guild=guild)
            self.logger.info(f"Connected to guild {self.guild_id}")
        except discord.HTTPException as e:
            self.logger.error(f"Failed to sync commands to guild {self.guild_id}: {e}")

    # pylint: disable=W0221
    async def on_message(self, message: discord.Message):
        """Event handler for processing incoming Discord messages.

        Converts Discord messages to HumanMessage objects and adds them to the
        message queue. Ignores messages sent by the bot itself.

        Args:
            message (discord.Message): The received Discord message

        Raises:
            Exception: If message queue processing fails
        """
        # Ignore messages from the bot itself
        if message.author == self.user:
            return

        # Create Message object and add to queue
        try:
            msg = HumanMessage(
                content=message.content,
                conversation_id=str(message.channel.id),
                additional_kwargs={
                    "author": message.author.name,
                    "message_id": message.id,
                    "timestamp": str(message.created_at.isoformat()),
                },
            )
            await self.message_queue.put(msg)  # type: ignore
            self.logger.info(f"Added message to queue: {msg}")
        except Exception as e:
            self.logger.error(f"Failed to add message to queue: {e}")
            raise e

    async def start(self, queue: PushOnlyQueue) -> None:  # type: ignore[override]
        """Start the Discord bot and connect it to the message queue.

        Args:
            queue (PushOnlyQueue): Queue for storing received messages

        Note:
            Requires DISCORD_TOKEN environment variable to be set
        """
        self.message_queue = queue
        await super().start(os.getenv("DISCORD_TOKEN", ""))

    async def send(self, request: Message, response: Message) -> None:
        """Send a response message to the appropriate Discord channel.

        Args:
            request (Message): The original request message (unused)
            response (Message): The response to send to Discord

        Raises:
            ValueError: If the response's conversation_id is None
            Exception: If message sending fails
        """
        try:
            if response.conversation_id is None:
                raise ValueError("conversation_id cannot be None")
            channel = self.get_channel(int(response.conversation_id))
            await channel.send(response.content)  # type: ignore[union-attr]
        except Exception as e:
            self.logger.error(f"Failed to post output: {e}")
            raise e


================================================
File: /galadriel/clients/gradio_client.py
================================================
import asyncio
from typing import Optional
import logging
from datetime import datetime
import gradio as gr

from galadriel import AgentInput, AgentOutput
from galadriel.entities import Message, PushOnlyQueue, HumanMessage


class GradioClient(AgentInput, AgentOutput):
    """A Gradio-based web interface for chat interactions.

    This class implements both AgentInput and AgentOutput interfaces to provide
    a web-based chat interface using Gradio. It supports real-time message
    exchange between users and the agent system.

    Attributes:
        message_queue (Optional[PushOnlyQueue]): Queue for storing messages to be processed
        is_public (bool): Whether to share the Gradio interface publicly
        logger (logging.Logger): Logger instance for tracking client activities
        conversation_id (str): Identifier for the chat conversation
        input_queue (asyncio.Queue[str]): Queue for storing user inputs
        output_queue (asyncio.Queue[str]): Queue for storing agent responses
        interface (gr.Blocks): The Gradio interface instance
        chatbot (gr.Chatbot): The chat interface component
    """

    def __init__(self, logger: Optional[logging.Logger] = None, is_public: Optional[bool] = False):
        """Initialize the Gradio client interface.

        Args:
            logger (Optional[logging.Logger]): Custom logger instance. If None,
                                             creates a default logger
        """
        self.message_queue: Optional[PushOnlyQueue] = None
        self.is_public = is_public
        self.logger = logger or logging.getLogger("gradio_client")
        self.conversation_id = "gradio"
        self.input_queue: asyncio.Queue[str] = asyncio.Queue()
        self.output_queue: asyncio.Queue[str] = asyncio.Queue()

        # Initialize the Gradio interface with a chatbot component
        with gr.Blocks() as self.interface:
            self.chatbot = gr.Chatbot(
                value=[],
                label="Agent",
                resizeable=True,
                scale=1,
            )
            with gr.Row():
                self.msg = gr.Textbox(
                    label="Message",
                    placeholder="Type a message...",
                    show_label=False,
                    scale=7,
                )
                self.submit = gr.Button("Send", scale=1)
            self.clear = gr.Button("Clear")

            # Set up event handlers with chaining
            self.msg.submit(self._handle_message, [self.msg, self.chatbot], [self.msg, self.chatbot]).then(
                self._process_response, [self.chatbot], [self.chatbot]
            )

            self.submit.click(self._handle_message, [self.msg, self.chatbot], [self.msg, self.chatbot]).then(
                self._process_response, [self.chatbot], [self.chatbot]
            )

            self.clear.click(lambda: [], None, self.chatbot, queue=False)

    async def _handle_message(self, message: str, history):
        """Process incoming messages from the Gradio interface.

        Args:
            message (str): The user's input message
            history: The current chat history

        Returns:
            tuple: A tuple containing (empty string, updated history)
        """
        if not message:
            return "", history

        await self.input_queue.put(message)
        history = history or []
        history.append((message, None))
        return "", history

    async def _process_response(self, history):
        """Process the agent's response and update the chat interface.

        Waits for a response from the output queue and adds it to the chat history.

        Args:
            history: The current chat history

        Returns:
            list: Updated chat history including the new response
        """
        while self.output_queue.empty():
            await asyncio.sleep(0.1)
        new_message = await self.output_queue.get()
        history.append((None, new_message))
        return history

    async def start(self, queue: PushOnlyQueue) -> None:
        """Start the Gradio interface and begin processing messages.

        Launches the web interface and starts the message processing loop.

        Args:
            queue (PushOnlyQueue): Queue for storing messages to be processed
        """
        self.message_queue = queue

        # Launch Gradio interface in a background thread
        self.interface.queue()
        self.interface.launch(server_name="0.0.0.0", server_port=7860, share=self.is_public, prevent_thread_lock=True)
        # Log the local URL for accessing the Gradio interface
        if not self.is_public:
            self.logger.info("Gradio interface available at: http://0.0.0.0:7860")

        # Process messages from input queue
        while True:
            if not self.input_queue.empty():
                user_input = await self.input_queue.get()

                msg = HumanMessage(
                    content=user_input,
                    conversation_id=self.conversation_id,
                    additional_kwargs={
                        "author": "user_gradio",
                        "message_id": "gradio",
                        "timestamp": str(datetime.now().isoformat()),
                    },
                )
                await self.message_queue.put(msg)

            await asyncio.sleep(0.1)

    async def send(self, request: Message, response: Message) -> None:
        """Send a response message to the Gradio interface.

        Args:
            request (Message): The original request message (unused)
            response (Message): The response to display in the chat interface

        Raises:
            ValueError: If the response message is empty
        """
        message = response.content
        if not message:
            self.logger.error("No message to send")
            raise ValueError("No message to send")
        await self.output_queue.put(message)


================================================
File: /galadriel/clients/telegram_client.py
================================================
import logging
from datetime import datetime
from typing import Optional

from telebot import types
from telebot.async_telebot import AsyncTeleBot

from galadriel import AgentInput
from galadriel import AgentOutput
from galadriel.entities import HumanMessage
from galadriel.entities import Message
from galadriel.entities import PushOnlyQueue


class TelegramClient(AgentInput, AgentOutput):
    """A Telegram bot client that handles bidirectional message communication.

    This class implements both AgentInput and AgentOutput interfaces to provide
    integration with the Telegram messaging platform. It handles incoming messages
    from Telegram users and sends agent responses back to the appropriate chats.

    Attributes:
        token (str): The Telegram bot API token
        bot (AsyncTeleBot): The async Telegram bot instance
        queue (Optional[PushOnlyQueue]): Queue for storing incoming messages
        logger (logging.Logger): Logger instance for tracking bot activities
    """

    def __init__(self, token: str, logger: logging.Logger):
        """Initialize the Telegram client.

        Args:
            token (str): The Telegram bot API token for authentication
            logger (logging.Logger): Logger instance for tracking bot activities
        """
        self.token = token
        self.bot = AsyncTeleBot(token)
        self.queue: Optional[PushOnlyQueue] = None
        self.logger = logger

    async def start(self, queue: PushOnlyQueue) -> None:
        """Start the Telegram bot and begin processing messages.

        Sets up message handling and starts the bot's polling loop to receive
        messages from Telegram.

        Args:
            queue (PushOnlyQueue): Queue for storing incoming messages

        Note:
            This method runs indefinitely until the bot is stopped.
        """
        self.queue = queue

        @self.bot.message_handler(func=lambda message: True)
        async def handle_incoming_message(message: types.Message):
            """Process incoming Telegram messages.

            Converts Telegram messages to HumanMessage objects and adds them
            to the processing queue.

            Args:
                message (types.Message): The incoming Telegram message

            Note:
                The author name is constructed from the user's first_name and last_name
                if available, falling back to username or user ID if not.
            """
            if not self.queue:
                self.logger.warning("Queue not initialized. Ignoring incoming message.")
                return

            user = message.from_user
            # Construct author name from available user information
            author = f"{user.first_name} {user.last_name}".strip() if user.first_name else user.username or str(user.id)

            incoming = HumanMessage(
                content=message.text,
                conversation_id=str(message.chat.id),
                additional_kwargs={
                    "author": author,
                    "message_id": message.id,
                    "timestamp": str(datetime.now().isoformat()),
                },
            )
            await self.queue.put(incoming)
            self.logger.info(f"Enqueued message: {incoming}")

        self.logger.info("Starting AsyncTeleBot polling...")
        await self.bot.infinity_polling()

    async def send(self, request: Message, response: Message):
        """Send a response message back to the Telegram chat.

        Args:
            request (Message): The original request message (unused)
            response (Message): The response to send to Telegram

        Note:
            The response must include a valid conversation_id that matches
            the Telegram chat ID where the response should be sent.

        Raises:
            Warning: If no conversation_id is found in the response
        """
        if not response.conversation_id:
            self.logger.warning("No conversation_id found in request; cannot respond.")
            return

        chat_id = response.conversation_id

        await self.bot.send_message(chat_id, response.content)
        self.logger.info(f"Posted output to chat {chat_id}: {response.content}")


================================================
File: /galadriel/repository/wallet_repository.py
================================================
import json
import os
from typing import Optional

from solders.keypair import Keypair  # pylint: disable=E0401


class WalletRepository:
    def __init__(self, key_path: str):
        keypair = _get_private_key(key_path=key_path)
        if keypair is None:
            raise ValueError("No admin key found")
        self.wallet = keypair

    def get_wallet_address(self) -> str:
        """
        Get the wallet address.

        Returns:
            str: The wallet address.
        """
        return str(self.wallet.pubkey())

    def get_wallet(self) -> Keypair:
        """
        Get the wallet keypair.

        Returns:
            Keypair: The wallet keypair.
        """
        return self.wallet


def _get_private_key(key_path: str) -> Optional[Keypair]:
    if os.path.exists(key_path):
        with open(key_path, "r", encoding="utf-8") as file:
            seed = json.load(file)
            return Keypair.from_bytes(seed)
    return None


================================================
File: /galadriel/tools/composio_converter.py
================================================
from composio_langchain import App
from composio_langchain import ComposioToolSet

from galadriel.core_agent import Tool


def convert_action(api_key: str, action: str) -> Tool:
    """
    Convert a single Composio action into a Galadriel Tool.

    This allows importing individual actions from Composio, like 'WEATHERMAP_WEATHER',
    rather than importing an entire app's worth of tools.

    Args:
        api_key (str): Composio API key
        action (str): Name of the Composio action to convert

    Returns:
        Tool: The converted Galadriel Tool
    """
    composio_toolset = ComposioToolSet(api_key=api_key)
    return Tool.from_langchain(composio_toolset.get_tools(actions=[action])[0])


def convert_app(api_key: str, app: App) -> list[Tool]:
    """
    Convert all tools from a Composio App into Galadriel Tools.

    Composio organizes related tools into Apps (e.g. GitHub, Weather).
    This converts all tools within a specified app into Galadriel Tools.

    Args:
        api_key (str): Composio API key
        app (App): The Composio App to convert

    Returns:
        list[Tool]: List of converted Galadriel Tools
    """
    composio_toolset = ComposioToolSet(api_key=api_key)
    return [Tool.from_langchain(tool) for tool in composio_toolset.get_tools(apps=[app])]


================================================
File: /galadriel/tools/retriever.py
================================================
"""
Document Retrieval Module

This module provides semantic search functionality for retrieving relevant
documents or document segments based on user queries. It uses the BM25
algorithm for ranking document relevance.

Key Features:
- Semantic document search
- BM25-based relevance ranking
- Support for multiple document formats
- Configurable result count

Here's an example of how to use the RetrieverTool:
https://docs.galadriel.com/galadriel-network/tutorials/rag
"""

from typing import List

from langchain.docstore.document import Document
from langchain_community.retrievers import BM25Retriever

from galadriel.core_agent import Tool


class RetrieverTool(Tool):
    """A tool for semantic document retrieval using BM25 ranking.

    This tool enables semantic search across a collection of documents,
    returning the most relevant document segments based on the query.
    It uses the BM25 algorithm for ranking document relevance.

    Attributes:
        name (str): Tool identifier for the agent system
        description (str): Description of the tool's functionality
        inputs (dict): Schema for the required input parameters
        output_type (str): Type of data returned by the tool
        retriever (BM25Retriever): The underlying BM25 retrieval engine

    Example:
        docs = [Document(page_content="some content"), ...]
        retriever = RetrieverTool(docs)
        results = retriever.forward("search query")
    """

    name = "retriever"
    description = (
        "Uses semantic search to retrieve the parts of documentation that could be most relevant to answer your query."
    )
    inputs = {
        "query": {
            "type": "string",
            "description": "The query to perform. This should be semantically close to your target documents. "
            "Use the affirmative form rather than a question.",
        }
    }
    output_type = "string"

    def __init__(self, docs: List[Document], **kwargs):
        """Initialize the retriever tool with a document collection.

        Args:
            docs (List[Document]): List of documents to index for retrieval
            **kwargs: Additional arguments passed to parent Tool class

        Note:
            - Documents should be pre-processed and split if needed
            - The BM25Retriever is initialized to return top 10 results
        """
        super().__init__(**kwargs)
        self.retriever = BM25Retriever.from_documents(docs, k=10)

    # pylint:disable=W0221
    def forward(self, query: str) -> str:
        """Perform a semantic search across the document collection.

        Retrieves and formats the most relevant document segments based
        on the input query using BM25 ranking.

        Args:
            query (str): The search query string

        Returns:
            str: A formatted string containing the retrieved documents,
                 with each document prefixed by its index

        Raises:
            AssertionError: If the query is not a string

        Note:
            - Returns top 10 most relevant documents
            - Documents are numbered and clearly separated in the output
            - Query should be in affirmative form for best results
        """
        assert isinstance(query, str), "Your search query must be a string"

        docs = self.retriever.invoke(
            query,
        )
        return "\nRetrieved documents:\n" + "".join(
            [f"\n\n===== Document {str(i)} =====\n" + doc.page_content for i, doc in enumerate(docs)]
        )


================================================
File: /galadriel/tools/web3/coingecko.py
================================================
import os
import requests

from galadriel.core_agent import Tool


class CoingeckoTool(Tool):
    """Base class for Coingecko API tools.

    This class provides common functionality for accessing the Coingecko API,
    including API key management and authentication.

    Required Environment Variables:
        COINGECKO_API_KEY: Your Coingecko API key for authentication

    For more information about Coingecko API, see:
    https://www.coingecko.com/api/documentation
    """

    def __init__(self, *args, **kwargs):
        """Initialize the Coingecko tool.

        Args:
            *args: Variable length argument list passed to parent Tool class
            **kwargs: Arbitrary keyword arguments passed to parent Tool class

        Raises:
            ValueError: If COINGECKO_API_KEY environment variable is not set
        """
        self.api_key = os.getenv("COINGECKO_API_KEY")
        if not self.api_key:
            raise ValueError("COINGECKO_API_KEY environment variable is not set")
        super().__init__(*args, **kwargs)


class GetCoinPriceTool(CoingeckoTool):
    """Tool for retrieving current cryptocurrency price and market data.

    Fetches current price, market cap, 24hr volume, and 24hr price change
    for a specified cryptocurrency.

    Attributes:
        name (str): Tool identifier for the agent system
        description (str): Description of the tool's functionality
        inputs (dict): Schema for the required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = "get_coin_price"
    description = "This is a tool that returns the price of given crypto token together with market cap, 24hr vol and 24hr change."  # pylint: disable=C0301
    inputs = {
        "task": {
            "type": "string",
            "description": "The full name of the token. For example 'solana' not 'sol'",
        }
    }
    output_type = "string"

    def forward(self, task: str) -> str:  # pylint: disable=W0221
        """Fetch current price and market data for a cryptocurrency.

        Args:
            task (str): The full name of the cryptocurrency (e.g., 'bitcoin')

        Returns:
            str: JSON string containing price and market data

        Note:
            Returns data including:
            - Current price in USD
            - Market capitalization
            - 24-hour trading volume
            - 24-hour price change percentage
            - Last updated timestamp
        """
        response = call_coingecko_api(
            api_key=self.api_key,
            request="https://api.coingecko.com/api/v3/simple/price"
            "?vs_currencies=usd"
            "&include_market_cap=true"
            "&include_24hr_vol=true"
            "&include_24hr_change=true"
            "&include_last_updated_at=true"
            "&precision=2"
            "&ids=" + task,
        )
        data = response.json()
        return data


class GetCoinHistoricalDataTool(CoingeckoTool):
    """Tool for retrieving historical cryptocurrency price data.

    Fetches historical price data for a specified cryptocurrency over
    a given time period.

    Attributes:
        name (str): Tool identifier for the agent system
        description (str): Description of the tool's functionality
        inputs (dict): Schema for the required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = "get_coin_historical_data"
    description = "This is a tool that returns the historical data of given crypto token."
    inputs = {
        "task": {
            "type": "string",
            "description": "The full name of the token. For example 'solana' not 'sol'",
        },
        "days": {
            "type": "string",
            "description": "Data up to number of days ago, you may use any integer for number of days",
        },
    }
    output_type = "string"

    def forward(self, task: str, days: str) -> str:  # pylint: disable=W0221
        """Fetch historical price data for a cryptocurrency.

        Args:
            task (str): The full name of the cryptocurrency (e.g., 'bitcoin')
            days (str): Number of days of historical data to retrieve

        Returns:
            str: JSON string containing historical price data

        Note:
            Returns time series data including prices, market caps, and volumes
        """
        response = call_coingecko_api(
            api_key=self.api_key,
            request="https://api.coingecko.com/api/v3/coins/" + task + "/market_chart?vs_currency=usd&days=" + days,
        )
        data = response.json()
        return data


class FetchTrendingCoinsTool(CoingeckoTool):
    """Tool for retrieving currently trending cryptocurrencies.

    Fetches a list of cryptocurrencies that are currently trending
    on CoinGecko.

    Attributes:
        name (str): Tool identifier for the agent system
        description (str): Description of the tool's functionality
        inputs (dict): Schema for the required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = "fetch_trending_coins"
    description = "This is a tool that returns the trending coins on coingecko."
    inputs = {
        "dummy": {
            "type": "string",
            "description": "Dummy argument to make the tool work",
        }
    }
    output_type = "string"

    def forward(self, dummy: str) -> str:  # pylint: disable=W0221, W0613
        """Fetch currently trending cryptocurrencies.

        Args:
            dummy (str): Unused parameter required by tool interface

        Returns:
            str: JSON string containing trending cryptocurrency data
        """
        response = call_coingecko_api(
            api_key=self.api_key,
            request="https://api.coingecko.com/api/v3/search/trending",
        )
        data = response.json()
        return data


def call_coingecko_api(api_key: str, request: str) -> requests.Response:
    """Make an authenticated request to the Coingecko API.

    Args:
        api_key (str): Coingecko API key for authentication
        request (str): Complete API request URL

    Returns:
        requests.Response: Response from the Coingecko API

    Note:
        Includes a 30-second timeout for API requests
    """
    headers = {"accept": "application/json", "x-cg-demo-api-key": api_key}
    return requests.get(
        request,
        headers=headers,
        timeout=30,
    )


if __name__ == "__main__":
    get_coin_price = GetCoinPriceTool()
    print(get_coin_price.forward("ethereum"))


================================================
File: /galadriel/tools/web3/wallet_tool.py
================================================
import os
from galadriel.core_agent import Tool
from galadriel.repository.wallet_repository import WalletRepository


class WalletTool(Tool):
    """Base class for web3 tools that require wallet access.

    This class provides common wallet functionality for tools that need
    to interact with the Solana blockchain using a wallet. It handles
    wallet initialization and provides access to the wallet repository.

    Attributes:
        wallet_repository (WalletRepository): Repository for managing wallet access

    Example:
        class MyWeb3Tool(WalletTool):
            def __init__(self, *args, **kwargs):
                super().__init__(*args, **kwargs)
                # Additional initialization here

            def forward(self, ...):
                wallet = self.wallet_repository.get_wallet()
                # Use wallet for transactions
    """

    def __init__(self, *args, **kwargs):
        """Initialize the wallet tool.

        Sets up the wallet repository using the keypair file specified
        in environment variables.

        Args:
            *args: Variable length argument list passed to parent Tool class
            **kwargs: Arbitrary keyword arguments passed to parent Tool class

        Raises:
            ValueError: If SOLANA_KEY_PATH environment variable is not set

        Note:
            The keypair file should be kept secure and never committed to
            version control.
        """
        key_path = os.getenv("SOLANA_KEY_PATH")
        if not key_path:
            raise ValueError("SOLANA_KEY_PATH environment variable is not set")

        # Initialize wallet repository with keypair file
        self.wallet_repository = WalletRepository(key_path)

        # Initialize parent Tool class
        super().__init__(*args, **kwargs)


================================================
File: /galadriel/tools/web3/solana_tools.py
================================================
"""
Solana Tools Module

This module provides tools for interacting with the Solana blockchain,
specifically for managing user token balances and portfolios.

Key Features:
- User balance tracking
- Portfolio management
- Token balance queries
- Multi-user support
"""

import asyncio
import logging
from typing import Optional

from solana.rpc.commitment import Confirmed
from solders.pubkey import Pubkey  # type: ignore # pylint: disable=E0401

from spl.token.async_client import AsyncToken
from spl.token.constants import TOKEN_PROGRAM_ID
from spl.token.instructions import get_associated_token_address

from galadriel.core_agent import tool
from galadriel.tools.web3.wallet_tool import WalletTool

logger = logging.getLogger(__name__)

LAMPORTS_PER_SOL = 1_000_000_000


@tool
def get_user_balance(user_address: str, token: str) -> Optional[float]:
    """
    Retrieves the user's balance for a specific token from the blockchain.

    Args:
        user_address: The address of the user.
        token: The token address in solana.

    Returns:
        The balance of the user for the specified token, or None if the balance is not available.
    """
    return asyncio.run(get_user_token_balance(user_address, token))


class GetAdminWalletAddressTool(WalletTool):
    name = "get_admin_wallet_address"
    description = "This tool returns the wallet address of the admin."
    inputs = {"dummy": {"type": "string", "description": "Dummy input"}}
    output_type = "string"

    # pylint:disable=W0221,W0613
    def forward(self, dummy: str) -> str:
        return self.wallet_repository.get_wallet_address()


async def get_user_token_balance(self, user_address: str, token_address: Optional[str] = None) -> Optional[float]:
    """Query a user's token balance from the Solana blockchain.

    Fetches the current balance of either SOL or an SPL token for
    a given wallet address directly from the blockchain.

    Args:
        user_address (str): The user's Solana wallet address
        token_address (Optional[str]): The token's mint address, or None for SOL

    Returns:
        Optional[float]: The token balance, or None if the query fails

    Raises:
        Exception: If the balance query fails

    Note:
        - For SOL balance, uses RPC getBalance
        - For SPL tokens, uses Associated Token Account (ATA)
        - Handles token decimal conversion
        - Returns None if token account doesn't exist
    """
    try:
        user_pubkey = Pubkey.from_string(user_address)

        # Handle SOL balance query
        if not token_address:
            response = await self.async_client.get_balance(user_pubkey, commitment=Confirmed)
            return response.value / LAMPORTS_PER_SOL

        # Handle SPL token balance query
        token_address = Pubkey.from_string(token_address)  # type: ignore
        spl_client = AsyncToken(self.async_client, token_address, TOKEN_PROGRAM_ID, user_pubkey)  # type: ignore

        # Verify token mint is initialized
        mint = await spl_client.get_mint_info()
        if not mint.is_initialized:
            raise ValueError("Token mint is not initialized.")

        # Get balance from Associated Token Account
        wallet_ata = get_associated_token_address(user_pubkey, token_address)  # type: ignore
        response = await self.async_client.get_token_account_balance(wallet_ata)
        if response.value is None:
            return None

        response = response.value.ui_amount
        logger.info(f"Balance response: {response}")

        return float(response)

    except Exception as error:
        raise Exception(f"Failed to get balance: {str(error)}") from error  # pylint: disable=W0719


================================================
File: /galadriel/tools/web3/jupiter.py
================================================
import asyncio
import base64
import json

from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Processed, Confirmed
from solana.rpc.types import TxOpts
from solders import message
from solders.keypair import Keypair  # pylint: disable=E0401
from solders.pubkey import Pubkey  # pylint: disable=E0401
from solders.transaction import VersionedTransaction  # pylint: disable=E0401

from spl.token.async_client import AsyncToken
from spl.token.constants import TOKEN_PROGRAM_ID

from jupiter_python_sdk.jupiter import Jupiter

from galadriel.tools.web3.wallet_tool import WalletTool


# API endpoints for Jupiter Protocol
SOLANA_API_URL = "https://api.mainnet-beta.solana.com"
JUPITER_QUOTE_API_URL = "https://quote-api.jup.ag/v6/quote?"
JUPITER_SWAP_API_URL = "https://quote-api.jup.ag/v6/swap"
JUPITER_OPEN_ORDER_API_URL = "https://jup.ag/api/limit/v1/createOrder"
JUPITER_CANCEL_ORDERS_API_URL = "https://jup.ag/api/limit/v1/cancelOrders"
JUPITER_QUERY_OPEN_ORDERS_API_URL = "https://jup.ag/api/limit/v1/openOrders?wallet="
JUPITER_QUERY_ORDER_HISTORY_API_URL = "https://jup.ag/api/limit/v1/orderHistory"
JUPITER_QUERY_TRADE_HISTORY_API_URL = "https://jup.ag/api/limit/v1/tradeHistory"


class SwapTokenTool(WalletTool):
    """Tool for performing token swaps using Jupiter Protocol on Solana.

    This tool enables token swaps between any two SPL tokens using Jupiter's
    aggregator for optimal routing and pricing.

    Attributes:
        name (str): Tool identifier for the agent system
        description (str): Description of the tool's functionality
        inputs (dict): Schema for the required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = "swap_token"
    description = "Swaps one token for another in the user's portfolio."
    inputs = {
        "user_address": {
            "type": "string",
            "description": "The solana address of the user",
        },
        "token1": {"type": "string", "description": "The address of the token to sell"},
        "token2": {"type": "string", "description": "The address of the token to buy"},
        "amount": {"type": "number", "description": "The amount of token1 to swap"},
    }
    output_type = "string"

    def forward(self, user_address: str, token1: str, token2: str, amount: float) -> str:  # pylint: disable=W0221
        """Execute a token swap transaction.

        Args:
            user_address (str): The Solana address of the user
            token1 (str): The address of the token to sell
            token2 (str): The address of the token to buy
            amount (float): The amount of token1 to swap

        Returns:
            str: A success message containing the transaction signature

        Note:
            Uses asyncio to run the swap operation in an event loop
        """
        wallet = self.wallet_repository.get_wallet()

        result = asyncio.run(swap(wallet, user_address, token1, float(token2), int(amount)))

        return f"Successfully swapped {amount} {token1} for {token2}, tx sig: {result}."


# pylint: disable=R0914
async def swap(
    wallet: Keypair,
    output_mint: str,
    input_mint: str,
    input_amount: float,
    slippage_bps: int = 300,
) -> str:
    """Execute a token swap using Jupiter Protocol.

    Performs a swap between two tokens using Jupiter's aggregator for optimal
    routing and pricing. Handles transaction construction, signing, and confirmation.

    Args:
        wallet (Keypair): The signer wallet for the transaction
        output_mint (str): Target token mint address
        input_mint (str): Source token mint address
        input_amount (float): Amount of input token to swap
        slippage_bps (int, optional): Slippage tolerance in basis points. Defaults to 300 (3%)

    Returns:
        str: The transaction signature

    Raises:
        Exception: If the swap fails for any reason

    Note:
        - Connects to Solana mainnet via RPC
        - Uses Jupiter's quote API for price discovery
        - Handles token decimal conversion
        - Confirms transaction completion
        - Prints transaction URLs for monitoring
    """
    # Initialize clients
    async_client = AsyncClient(SOLANA_API_URL)
    jupiter = Jupiter(
        async_client=async_client,
        keypair=wallet,
        quote_api_url=JUPITER_QUOTE_API_URL,
        swap_api_url=JUPITER_SWAP_API_URL,
        open_order_api_url=JUPITER_OPEN_ORDER_API_URL,
        cancel_orders_api_url=JUPITER_CANCEL_ORDERS_API_URL,
        query_open_orders_api_url=JUPITER_QUERY_OPEN_ORDERS_API_URL,
        query_order_history_api_url=JUPITER_QUERY_ORDER_HISTORY_API_URL,
        query_trade_history_api_url=JUPITER_QUERY_TRADE_HISTORY_API_URL,
    )

    # Convert addresses to strings
    input_mint = str(input_mint)
    output_mint = str(output_mint)

    # Get token decimals and adjust amount
    spl_client = AsyncToken(async_client, Pubkey.from_string(input_mint), TOKEN_PROGRAM_ID, wallet)
    mint = await spl_client.get_mint_info()
    decimals = mint.decimals
    input_amount = int(input_amount * 10**decimals)

    try:
        # Get swap transaction data
        transaction_data = await jupiter.swap(
            input_mint,
            output_mint,
            input_amount,
            only_direct_routes=False,
            slippage_bps=slippage_bps,
        )

        # Construct and sign transaction
        raw_transaction = VersionedTransaction.from_bytes(base64.b64decode(transaction_data))
        signature = wallet.sign_message(message.to_bytes_versioned(raw_transaction.message))
        signed_txn = VersionedTransaction.populate(raw_transaction.message, [signature])

        # Send and confirm transaction
        opts = TxOpts(skip_preflight=False, preflight_commitment=Processed)
        result = await async_client.send_raw_transaction(txn=bytes(signed_txn), opts=opts)
        print(f"Transaction sent: {json.loads(result.to_json())}")
        transaction_id = json.loads(result.to_json())["result"]
        print(f"Transaction sent: https://explorer.solana.com/tx/{transaction_id}")
        await async_client.confirm_transaction(signature, commitment=Confirmed)
        print(f"Transaction confirmed: https://explorer.solana.com/tx/{transaction_id}")
        return str(signature)

    except Exception as e:
        raise Exception(f"Swap failed: {str(e)}")  # pylint: disable=W0719


================================================
File: /galadriel/tools/web3/raydium_cpmm.py
================================================
"""
Raydium Constant Product Market Maker (CPMM) Module

This module provides tools for interacting with Raydium's CPMM pools on the
Solana blockchain. It enables token swaps using SOL as the base currency
through Raydium's AMM protocol.

Key Features:
- Buy tokens with SOL
- Sell tokens for SOL
- Pool state management
- Price calculation with slippage protection
- Automatic WSOL handling
"""

import base64
from dataclasses import dataclass
from enum import Enum
import logging
import os
import struct
from typing import Optional
from solana.rpc.commitment import Processed
from solana.rpc.types import TokenAccountOpts, TxOpts
from solana.rpc.api import Client
from solders.compute_budget import set_compute_unit_limit, set_compute_unit_price  # type: ignore # pylint: disable=E0401
from solders.message import MessageV0  # type: ignore # pylint: disable=E0401
from solders.instruction import AccountMeta, Instruction  # type: ignore # pylint: disable=E0401
from solders.keypair import Keypair  # type: ignore # pylint: disable=E0401
from solders.pubkey import Pubkey  # type: ignore # pylint: disable=E0401
from solders.system_program import (  # type: ignore # pylint: disable=E0401
    CreateAccountWithSeedParams,
    create_account_with_seed,
)
from solders.transaction import VersionedTransaction  # type: ignore # pylint: disable=E0401
from solders.account_decoder import ParsedAccount  # type: ignore # pylint: disable=E0401
from spl.token.client import Token
from spl.token.instructions import (
    CloseAccountParams,
    InitializeAccountParams,
    close_account,
    create_associated_token_account,
    get_associated_token_address,
    initialize_account,
)

from construct import (
    Struct,
    Int64ul,
    Bytes,
    Array,
    Padding,
    Int8ul,
    Flag,
    Int16ul,
    GreedyRange,
    Adapter,
)


from galadriel.tools.web3.wallet_tool import WalletTool
from galadriel.tools.web3.raydium_openbook import confirm_txn, get_token_balance

logger = logging.getLogger(__name__)

UNIT_BUDGET = 150_000
UNIT_PRICE = 1_000_000

# Raydium AMM V4 devnet addresses
RAYDIUM_CREATE_CPMM_POOL_PROGRAM = Pubkey.from_string("CPMDWBwJDtYax9qW7AyRuVC19Cc4L4Vcy4n2BHAbHkCW")
CREATE_CPMM_POOL_AUTHORITY = Pubkey.from_string("7rQ1QFNosMkUCuh7Z7fPbTHvh73b68sQYdirycEzJVuw")

TOKEN_PROGRAM_ID = Pubkey.from_string("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
ACCOUNT_LAYOUT_LEN = 165
WSOL = Pubkey.from_string("So11111111111111111111111111111111111111112")
SOL_DECIMAL = 1e9

client = Client("https://api.devnet.solana.com")  # type: ignore


@dataclass
class CpmmPoolKeys:
    """Data structure for Raydium CPMM pool configuration.

    Contains all necessary public keys and parameters for interacting
    with a Raydium CPMM pool.

    Attributes:
        pool_state (Pubkey): Pool state account address
        raydium_vault_auth_2 (Pubkey): Raydium vault authority
        amm_config (Pubkey): AMM configuration account
        pool_creator (Pubkey): Pool creator's address
        token_0_vault (Pubkey): Token 0 vault address
        token_1_vault (Pubkey): Token 1 vault address
        lp_mint (Pubkey): LP token mint address
        token_0_mint (Pubkey): Token 0 mint address
        token_1_mint (Pubkey): Token 1 mint address
        token_0_program (Pubkey): Token 0 program ID
        token_1_program (Pubkey): Token 1 program ID
        observation_key (Pubkey): Price observation account
        auth_bump (int): Authority bump seed
        status (int): Pool status
        lp_mint_decimals (int): LP token decimals
        mint_0_decimals (int): Token 0 decimals
        mint_1_decimals (int): Token 1 decimals
        lp_supply (int): Total LP token supply
        protocol_fees_token_0 (int): Protocol fees in token 0
        protocol_fees_token_1 (int): Protocol fees in token 1
        fund_fees_token_0 (int): Fund fees in token 0
        fund_fees_token_1 (int): Fund fees in token 1
        open_time (int): Pool opening timestamp
    """

    pool_state: Pubkey
    raydium_vault_auth_2: Pubkey
    amm_config: Pubkey
    pool_creator: Pubkey
    token_0_vault: Pubkey
    token_1_vault: Pubkey
    lp_mint: Pubkey
    token_0_mint: Pubkey
    token_1_mint: Pubkey
    token_0_program: Pubkey
    token_1_program: Pubkey
    observation_key: Pubkey
    auth_bump: int
    status: int
    lp_mint_decimals: int
    mint_0_decimals: int
    mint_1_decimals: int
    lp_supply: int
    protocol_fees_token_0: int
    protocol_fees_token_1: int
    fund_fees_token_0: int
    fund_fees_token_1: int
    open_time: int


class DIRECTION(Enum):
    """Enum for swap direction in CPMM pools.

    Values:
        BUY: Swap SOL for tokens
        SELL: Swap tokens for SOL
    """

    BUY = 0
    SELL = 1


CPMM_POOL_STATE_LAYOUT = Struct(
    Padding(8),
    "amm_config" / Bytes(32),
    "pool_creator" / Bytes(32),
    "token_0_vault" / Bytes(32),
    "token_1_vault" / Bytes(32),
    "lp_mint" / Bytes(32),
    "token_0_mint" / Bytes(32),
    "token_1_mint" / Bytes(32),
    "token_0_program" / Bytes(32),
    "token_1_program" / Bytes(32),
    "observation_key" / Bytes(32),
    "auth_bump" / Int8ul,
    "status" / Int8ul,
    "lp_mint_decimals" / Int8ul,
    "mint_0_decimals" / Int8ul,
    "mint_1_decimals" / Int8ul,
    "lp_supply" / Int64ul,
    "protocol_fees_token_0" / Int64ul,
    "protocol_fees_token_1" / Int64ul,
    "fund_fees_token_0" / Int64ul,
    "fund_fees_token_1" / Int64ul,
    "open_time" / Int64ul,
    "padding" / Array(32, Int64ul),
)

AMM_CONFIG_LAYOUT = Struct(
    Padding(8),
    "bump" / Int8ul,
    "disable_create_pool" / Flag,
    "index" / Int16ul,
    "trade_fee_rate" / Int64ul,
    "protocol_fee_rate" / Int64ul,
    "fund_fee_rate" / Int64ul,
    "create_pool_fee" / Int64ul,
    "protocol_owner" / Bytes(32),
    "fund_owner" / Bytes(32),
    "padding" / Array(16, Int64ul),
)


# pylint:disable=W0223
class UInt128Adapter(Adapter):
    def _decode(self, obj, context, path):
        return (obj.high << 64) | obj.low

    def _encode(self, obj, context, path):
        high = (obj >> 64) & ((1 << 64) - 1)
        low = obj & ((1 << 64) - 1)
        return {"high": high, "low": low}


UInt128ul = UInt128Adapter(Struct("low" / Int64ul, "high" / Int64ul))

OBSERVATION = Struct(
    "block_timestamp" / Int64ul,
    "cumulative_token_0_price_x32" / UInt128ul,
    "cumulative_token_1_price_x32" / UInt128ul,
)

OBSERVATION_STATE = Struct(
    Padding(8),
    "initialized" / Flag,
    "observationIndex" / Int16ul,
    "poolId" / Bytes(32),
    "observations" / GreedyRange(OBSERVATION),
    "padding" / GreedyRange(Int64ul),
)


class BuyTokenWithSolTool(WalletTool):
    """Tool for buying tokens with SOL using Raydium CPMM.

    Enables swapping SOL for any token available in Raydium CPMM pools.
    Handles WSOL wrapping/unwrapping automatically.

    Attributes:
        name (str): Tool identifier
        description (str): Description of the tool's functionality
        inputs (dict): Schema for required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = "buy_token_with_sol_cpmm"
    description = "Buy a token with SOL using the Raydium CPMM."
    inputs = {
        "pair_address": {
            "type": "string",
            "description": "The address of the CPMM pair",
        },
        "sol_in": {
            "type": "number",
            "description": "The amount of SOL to swap",
            "default": 0.01,
            "nullable": True,
        },
        "slippage": {
            "type": "integer",
            "description": "The slippage tolerance percentage",
            "default": 5,
            "nullable": True,
        },
    }
    output_type = "string"

    # pylint:disable=W0221
    def forward(self, pair_address: str, sol_in: float = 0.01, slippage: int = 5) -> str:
        """Execute a SOL to token swap.

        Args:
            pair_address (str): The Raydium CPMM pair address
            sol_in (float, optional): Amount of SOL to swap. Defaults to 0.01
            slippage (int, optional): Slippage tolerance percentage. Defaults to 5

        Returns:
            str: Transaction result message
        """
        payer_keypair = self.wallet_repository.get_wallet()
        result = buy(payer_keypair, pair_address, sol_in, slippage)
        return "Transaction successful" if result else "Transaction failed"


class SellTokenForSolTool(WalletTool):
    """Tool for selling tokens for SOL using Raydium CPMM.

    Enables swapping any token for SOL using Raydium CPMM pools.
    Handles WSOL wrapping/unwrapping automatically.

    Attributes:
        name (str): Tool identifier
        description (str): Description of the tool's functionality
        inputs (dict): Schema for required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = "sell_token_for_sol_cpmm"
    description = "Sell a token for SOL using the Raydium CPMM."
    inputs = {
        "pair_address": {
            "type": "string",
            "description": "The address of the CPMM pair",
        },
        "percentage": {
            "type": "integer",
            "description": "The percentage of token to sell",
            "default": 100,
        },
        "slippage": {
            "type": "integer",
            "description": "The slippage tolerance percentage",
            "default": 5,
        },
    }
    output_type = "string"

    # pylint:disable=W0221
    def forward(self, pair_address: str, percentage: int = 100, slippage: int = 5) -> str:
        """Execute a token to SOL swap.

        Args:
            pair_address (str): The Raydium CPMM pair address
            percentage (int, optional): Percentage of token to sell. Defaults to 100
            slippage (int, optional): Slippage tolerance percentage. Defaults to 5

        Returns:
            str: Transaction result message
        """
        payer_keypair = self.wallet_repository.get_wallet()
        result = sell(payer_keypair, pair_address, percentage, slippage)
        return "Transaction successful" if result else "Transaction failed"


# pylint:disable=R0914, R0915
def buy(payer_keypair: Keypair, pair_address: str, sol_in: float = 0.1, slippage: int = 1) -> bool:
    """Buy tokens with SOL using Raydium CPMM.

    Creates necessary token accounts, executes the swap, and handles cleanup
    of temporary accounts.

    Args:
        payer_keypair (Keypair): The transaction signer's keypair
        pair_address (str): The Raydium CPMM pair address
        sol_in (float, optional): Amount of SOL to swap. Defaults to 0.1
        slippage (int, optional): Slippage tolerance percentage. Defaults to 1

    Returns:
        bool: True if transaction succeeds, False otherwise

    Note:
        - Creates temporary WSOL account for swap
        - Creates token account if needed
        - Handles account cleanup after swap
        - Includes slippage protection
    """
    logger.info(f"Starting buy transaction for pair address: {pair_address}")

    logger.info("Fetching pool keys...")
    pool_keys: Optional[CpmmPoolKeys] = fetch_cpmm_pool_keys(pair_address)
    if pool_keys is None:
        logger.error("No pool keys found...")
        return False
    logger.info("Pool keys fetched successfully.")

    if pool_keys.token_0_mint == WSOL:
        mint = pool_keys.token_1_mint
        token_program = pool_keys.token_1_program
    else:
        mint = pool_keys.token_0_mint
        token_program = pool_keys.token_0_program

    logger.info("Calculating transaction amounts...")
    amount_in = int(sol_in * SOL_DECIMAL)

    base_reserve, quote_reserve, token_decimal = get_cpmm_reserves(pool_keys)
    amount_out = sol_for_tokens(sol_in, base_reserve, quote_reserve)
    logger.info(f"Estimated Amount Out: {amount_out}")

    slippage_adjustment = 1 - (slippage / 100)
    amount_out_with_slippage = amount_out * slippage_adjustment
    minimum_amount_out = int(amount_out_with_slippage * 10**token_decimal)
    logger.info(f"Amount In: {amount_in} | Minimum Amount Out: {minimum_amount_out}")

    logger.info("Checking for existing token account...")
    token_account_check = client.get_token_accounts_by_owner(payer_keypair.pubkey(), TokenAccountOpts(mint), Processed)
    if token_account_check.value:
        token_account = token_account_check.value[0].pubkey
        token_account_instruction = None
        logger.info("Token account found.")
    else:
        token_account = get_associated_token_address(payer_keypair.pubkey(), mint)
        token_account_instruction = create_associated_token_account(
            payer_keypair.pubkey(), payer_keypair.pubkey(), mint, token_program
        )
        logger.info("No existing token account found; creating associated token account.")

    logger.info("Generating seed for WSOL account...")
    seed = base64.urlsafe_b64encode(os.urandom(24)).decode("utf-8")
    wsol_token_account = Pubkey.create_with_seed(payer_keypair.pubkey(), seed, TOKEN_PROGRAM_ID)
    balance_needed = Token.get_min_balance_rent_for_exempt_for_account(client)

    logger.info("Creating and initializing WSOL account...")
    create_wsol_account_instruction = create_account_with_seed(
        CreateAccountWithSeedParams(
            from_pubkey=payer_keypair.pubkey(),
            to_pubkey=wsol_token_account,
            base=payer_keypair.pubkey(),
            seed=seed,
            lamports=int(balance_needed + amount_in),
            space=ACCOUNT_LAYOUT_LEN,
            owner=TOKEN_PROGRAM_ID,
        )
    )

    init_wsol_account_instruction = initialize_account(
        InitializeAccountParams(
            program_id=TOKEN_PROGRAM_ID,
            account=wsol_token_account,
            mint=WSOL,
            owner=payer_keypair.pubkey(),
        )
    )

    logger.info("Creating swap instructions...")
    swap_instruction = make_cpmm_swap_instruction(
        amount_in=amount_in,
        minimum_amount_out=minimum_amount_out,
        token_account_in=wsol_token_account,
        token_account_out=token_account,
        accounts=pool_keys,
        owner=payer_keypair.pubkey(),
        action=DIRECTION.BUY,
    )

    logger.info("Preparing to close WSOL account after swap...")
    close_wsol_account_instruction = close_account(
        CloseAccountParams(
            program_id=TOKEN_PROGRAM_ID,
            account=wsol_token_account,
            dest=payer_keypair.pubkey(),
            owner=payer_keypair.pubkey(),
        )
    )

    instructions = [
        set_compute_unit_limit(UNIT_BUDGET),
        set_compute_unit_price(UNIT_PRICE),
        create_wsol_account_instruction,
        init_wsol_account_instruction,
    ]

    if token_account_instruction:
        instructions.append(token_account_instruction)

    instructions.append(swap_instruction)
    instructions.append(close_wsol_account_instruction)

    logger.info("Compiling transaction message...")
    compiled_message = MessageV0.try_compile(
        payer_keypair.pubkey(),
        instructions,
        [],
        client.get_latest_blockhash().value.blockhash,
    )

    logger.info("Sending transaction...")
    txn_sig = client.send_transaction(
        txn=VersionedTransaction(compiled_message, [payer_keypair]),
        opts=TxOpts(skip_preflight=True),
    ).value
    logger.info(f"Transaction Signature: {txn_sig}")

    logger.info("Confirming transaction...")
    confirmed = confirm_txn(txn_sig)

    logger.info(f"Transaction confirmed: {confirmed}")
    return confirmed


# pylint:disable=R0914
def sell(payer_keypair: Keypair, pair_address: str, percentage: int = 100, slippage: int = 1) -> bool:
    """Sell tokens for SOL using Raydium CPMM.

    Swaps specified percentage of token balance for SOL with slippage protection.

    Args:
        payer_keypair (Keypair): The transaction signer's keypair
        pair_address (str): The Raydium CPMM pair address
        percentage (int, optional): Percentage of token balance to sell. Defaults to 100
        slippage (int, optional): Slippage tolerance percentage. Defaults to 1

    Returns:
        bool: True if transaction succeeds, False otherwise

    Note:
        - Creates temporary WSOL account for swap
        - Optionally closes token account if selling 100%
        - Includes slippage protection
    """
    try:
        logger.info("Fetching pool keys...")
        pool_keys: Optional[CpmmPoolKeys] = fetch_cpmm_pool_keys(pair_address)
        if pool_keys is None:
            logger.error("No pool keys found...")
            return False
        logger.info("Pool keys fetched successfully.")

        if pool_keys.token_0_mint == WSOL:
            mint = pool_keys.token_1_mint
            token_program_id = pool_keys.token_1_program
        else:
            mint = pool_keys.token_0_mint
            token_program_id = pool_keys.token_0_program

        logger.info("Retrieving token balance...")
        token_balance = get_token_balance(payer_keypair.pubkey(), str(mint))
        logger.info(f"Token Balance: {token_balance}")

        if token_balance == 0 or token_balance is None:
            logger.error("No token balance available to sell.")
            return False

        token_balance = token_balance * (percentage / 100)
        logger.info(f"Selling {percentage}% of the token balance, adjusted balance: {token_balance}")

        logger.info("Calculating transaction amounts...")
        base_reserve, quote_reserve, token_decimal = get_cpmm_reserves(pool_keys)
        amount_out = tokens_for_sol(token_balance, base_reserve, quote_reserve)
        logger.info(f"Estimated Amount Out: {amount_out}")

        slippage_adjustment = 1 - (slippage / 100)
        amount_out_with_slippage = amount_out * slippage_adjustment
        minimum_amount_out = int(amount_out_with_slippage * SOL_DECIMAL)

        amount_in = int(token_balance * 10**token_decimal)
        logger.info(f"Amount In: {amount_in} | Minimum Amount Out: {minimum_amount_out}")
        token_account = get_associated_token_address(payer_keypair.pubkey(), mint, token_program_id)

        logger.info("Generating seed and creating WSOL account...")
        seed = base64.urlsafe_b64encode(os.urandom(24)).decode("utf-8")
        wsol_token_account = Pubkey.create_with_seed(payer_keypair.pubkey(), seed, TOKEN_PROGRAM_ID)
        balance_needed = Token.get_min_balance_rent_for_exempt_for_account(client)

        create_wsol_account_instruction = create_account_with_seed(
            CreateAccountWithSeedParams(
                from_pubkey=payer_keypair.pubkey(),
                to_pubkey=wsol_token_account,
                base=payer_keypair.pubkey(),
                seed=seed,
                lamports=int(balance_needed),
                space=ACCOUNT_LAYOUT_LEN,
                owner=TOKEN_PROGRAM_ID,
            )
        )

        init_wsol_account_instruction = initialize_account(
            InitializeAccountParams(
                program_id=TOKEN_PROGRAM_ID,
                account=wsol_token_account,
                mint=WSOL,
                owner=payer_keypair.pubkey(),
            )
        )

        logger.info("Creating swap instructions...")
        swap_instructions = make_cpmm_swap_instruction(
            amount_in=amount_in,
            minimum_amount_out=minimum_amount_out,
            token_account_in=token_account,
            token_account_out=wsol_token_account,
            accounts=pool_keys,
            owner=payer_keypair.pubkey(),
            action=DIRECTION.SELL,
        )

        logger.info("Preparing to close WSOL account after swap...")
        close_wsol_account_instruction = close_account(
            CloseAccountParams(
                program_id=TOKEN_PROGRAM_ID,
                account=wsol_token_account,
                dest=payer_keypair.pubkey(),
                owner=payer_keypair.pubkey(),
            )
        )

        instructions = [
            set_compute_unit_limit(UNIT_BUDGET),
            set_compute_unit_price(UNIT_PRICE),
            create_wsol_account_instruction,
            init_wsol_account_instruction,
            swap_instructions,
            close_wsol_account_instruction,
        ]

        if percentage == 100:
            logger.info("Preparing to close token account after swap...")
            close_token_account_instruction = close_account(
                CloseAccountParams(
                    program_id=TOKEN_PROGRAM_ID,
                    account=token_account,
                    dest=payer_keypair.pubkey(),
                    owner=payer_keypair.pubkey(),
                )
            )
            instructions.append(close_token_account_instruction)

        logger.info("Compiling transaction message...")
        compiled_message = MessageV0.try_compile(
            payer_keypair.pubkey(),
            instructions,
            [],
            client.get_latest_blockhash().value.blockhash,
        )

        logger.info("Sending transaction...")
        txn_sig = client.send_transaction(
            txn=VersionedTransaction(compiled_message, [payer_keypair]),
            opts=TxOpts(skip_preflight=True),
        ).value
        logger.info(f"Transaction Signature: {txn_sig}")

        logger.info("Confirming transaction...")
        confirmed = confirm_txn(txn_sig)

        logger.info(f"Transaction confirmed: {confirmed}")
        return confirmed

    except Exception as e:
        logger.error(f"Error occurred during transaction: {e}")
        return False


def fetch_cpmm_pool_keys(pair_address: str) -> Optional[CpmmPoolKeys]:
    """Fetch the pool keys for a given Raydium CPMM pair address.

    Args:
        pair_address (str): The Raydium CPMM pair address

    Returns:
        Optional[CpmmPoolKeys]: The pool keys if found, None otherwise
    """
    try:
        pool_state = Pubkey.from_string(pair_address)
        pool_state_account = client.get_account_info_json_parsed(pool_state, commitment=Processed).value
        if not pool_state_account:
            logger.error("Pool state account not found.")
            return None
        pool_state_data = pool_state_account.data
        if isinstance(pool_state_data, ParsedAccount):
            pool_state_data = bytes(pool_state_data)
        parsed_data = CPMM_POOL_STATE_LAYOUT.parse(pool_state_data)

        pool_keys = CpmmPoolKeys(
            pool_state=pool_state,
            raydium_vault_auth_2=CREATE_CPMM_POOL_AUTHORITY,
            amm_config=Pubkey.from_bytes(parsed_data.amm_config),
            pool_creator=Pubkey.from_bytes(parsed_data.pool_creator),
            token_0_vault=Pubkey.from_bytes(parsed_data.token_0_vault),
            token_1_vault=Pubkey.from_bytes(parsed_data.token_1_vault),
            lp_mint=Pubkey.from_bytes(parsed_data.lp_mint),
            token_0_mint=Pubkey.from_bytes(parsed_data.token_0_mint),
            token_1_mint=Pubkey.from_bytes(parsed_data.token_1_mint),
            token_0_program=Pubkey.from_bytes(parsed_data.token_0_program),
            token_1_program=Pubkey.from_bytes(parsed_data.token_1_program),
            observation_key=Pubkey.from_bytes(parsed_data.observation_key),
            auth_bump=parsed_data.auth_bump,
            status=parsed_data.status,
            lp_mint_decimals=parsed_data.lp_mint_decimals,
            mint_0_decimals=parsed_data.mint_0_decimals,
            mint_1_decimals=parsed_data.mint_1_decimals,
            lp_supply=parsed_data.lp_supply,
            protocol_fees_token_0=parsed_data.protocol_fees_token_0,
            protocol_fees_token_1=parsed_data.protocol_fees_token_1,
            fund_fees_token_0=parsed_data.fund_fees_token_0,
            fund_fees_token_1=parsed_data.fund_fees_token_1,
            open_time=parsed_data.open_time,
        )

        return pool_keys

    except Exception as e:
        logger.error(f"Error fetching pool keys: {e}")
        return None


# pylint:disable=R0917
def make_cpmm_swap_instruction(
    amount_in: int,
    minimum_amount_out: int,
    token_account_in: Pubkey,
    token_account_out: Pubkey,
    accounts: CpmmPoolKeys,
    owner: Pubkey,
    action: DIRECTION,
) -> Instruction:
    """Create a swap instruction for a Raydium CPMM pool.

    Args:
        amount_in (int): The amount of input token to swap
        minimum_amount_out (int): The minimum amount of output token to receive
        token_account_in (Pubkey): The input token account
        token_account_out (Pubkey): The output token account
        accounts (CpmmPoolKeys): The pool keys
        owner (Pubkey): The transaction signer's keypair
        action (DIRECTION): The swap direction

    Returns:
        Instruction: The swap instruction
    """
    try:
        # Initialize variables with default values
        input_vault = None
        output_vault = None
        input_token_program = None
        output_token_program = None
        input_token_mint = None
        output_token_mint = None

        if action == DIRECTION.BUY:
            input_vault = accounts.token_0_vault
            output_vault = accounts.token_1_vault
            input_token_program = accounts.token_0_program
            output_token_program = accounts.token_1_program
            input_token_mint = accounts.token_0_mint
            output_token_mint = accounts.token_1_mint
        elif action == DIRECTION.SELL:
            input_vault = accounts.token_1_vault
            output_vault = accounts.token_0_vault
            input_token_program = accounts.token_1_program
            output_token_program = accounts.token_0_program
            input_token_mint = accounts.token_1_mint
            output_token_mint = accounts.token_0_mint
        else:
            raise ValueError("Invalid action")

        keys = [
            AccountMeta(pubkey=owner, is_signer=True, is_writable=True),
            AccountMeta(pubkey=accounts.raydium_vault_auth_2, is_signer=False, is_writable=False),
            AccountMeta(pubkey=accounts.amm_config, is_signer=False, is_writable=False),
            AccountMeta(pubkey=accounts.pool_state, is_signer=False, is_writable=True),
            AccountMeta(pubkey=token_account_in, is_signer=False, is_writable=True),
            AccountMeta(pubkey=token_account_out, is_signer=False, is_writable=True),
            AccountMeta(pubkey=input_vault, is_signer=False, is_writable=True),
            AccountMeta(pubkey=output_vault, is_signer=False, is_writable=True),
            AccountMeta(pubkey=input_token_program, is_signer=False, is_writable=False),
            AccountMeta(pubkey=output_token_program, is_signer=False, is_writable=False),
            AccountMeta(pubkey=input_token_mint, is_signer=False, is_writable=False),
            AccountMeta(pubkey=output_token_mint, is_signer=False, is_writable=False),
            AccountMeta(pubkey=accounts.observation_key, is_signer=False, is_writable=True),
        ]

        data = bytearray()
        data.extend(bytes.fromhex("8fbe5adac41e33de"))
        data.extend(struct.pack("<Q", amount_in))
        data.extend(struct.pack("<Q", minimum_amount_out))
        swap_instruction = Instruction(RAYDIUM_CREATE_CPMM_POOL_PROGRAM, bytes(data), keys)

        return swap_instruction
    except Exception as e:
        logger.error(f"Error occurred: {e}")
        raise e


def get_cpmm_reserves(pool_keys: CpmmPoolKeys):
    """Get the reserves for a given Raydium CPMM pool.

    Args:
        pool_keys (CpmmPoolKeys): The pool keys

    Returns:
        tuple: The base reserve, quote reserve, and token decimal
    """
    quote_vault = pool_keys.token_0_vault
    quote_decimal = pool_keys.mint_0_decimals
    quote_mint = pool_keys.token_0_mint

    base_vault = pool_keys.token_1_vault
    base_decimal = pool_keys.mint_1_decimals
    base_mint = pool_keys.token_1_mint

    protocol_fees_token_0 = pool_keys.protocol_fees_token_0 / (10**quote_decimal)
    fund_fees_token_0 = pool_keys.fund_fees_token_0 / (10**quote_decimal)
    protocol_fees_token_1 = pool_keys.protocol_fees_token_1 / (10**base_decimal)
    fund_fees_token_1 = pool_keys.fund_fees_token_1 / (10**base_decimal)

    balances_response = client.get_multiple_accounts_json_parsed([quote_vault, base_vault], Processed)
    balances = balances_response.value

    quote_account = balances[0]
    base_account = balances[1]
    quote_account_balance = quote_account.data.parsed["info"]["tokenAmount"]["uiAmount"]  # type: ignore
    base_account_balance = base_account.data.parsed["info"]["tokenAmount"]["uiAmount"]  # type: ignore

    if quote_account_balance is None or base_account_balance is None:
        logger.error("Error: One of the account balances is None.")
        return None, None, None

    if base_mint == WSOL:
        base_reserve = quote_account_balance - (protocol_fees_token_0 + fund_fees_token_0)
        quote_reserve = base_account_balance - (protocol_fees_token_1 + fund_fees_token_1)
        token_decimal = quote_decimal
    else:
        base_reserve = base_account_balance - (protocol_fees_token_1 + fund_fees_token_1)
        quote_reserve = quote_account_balance - (protocol_fees_token_0 + fund_fees_token_0)
        token_decimal = base_decimal

    logger.info(f"Base Mint: {base_mint} | Quote Mint: {quote_mint}")
    logger.info(f"Base Reserve: {base_reserve} | Quote Reserve: {quote_reserve} | Token Decimal: {token_decimal}")
    return base_reserve, quote_reserve, token_decimal


def sol_for_tokens(sol_amount, base_vault_balance, quote_vault_balance, swap_fee=0.25):
    """Calculate the amount of tokens received for a given amount of SOL.

    Args:
        sol_amount (float): The amount of SOL to swap
        base_vault_balance (float): The balance of the base token in the pool
        quote_vault_balance (float): The balance of the quote token in the pool
        swap_fee (float, optional): The swap fee. Defaults to 0.25

    Returns:
        float: The amount of tokens received
    """
    effective_sol_used = sol_amount - (sol_amount * (swap_fee / 100))
    constant_product = base_vault_balance * quote_vault_balance
    updated_base_vault_balance = constant_product / (quote_vault_balance + effective_sol_used)
    tokens_received = base_vault_balance - updated_base_vault_balance
    return round(tokens_received, 9)


def tokens_for_sol(token_amount, base_vault_balance, quote_vault_balance, swap_fee=0.25):
    """Calculate the amount of SOL received for a given amount of tokens.

    Args:
        token_amount (float): The amount of tokens to swap
        base_vault_balance (float): The balance of the base token in the pool
        quote_vault_balance (float): The balance of the quote token in the pool
        swap_fee (float, optional): The swap fee. Defaults to 0.25

    Returns:
        float: The amount of SOL received
    """
    effective_tokens_sold = token_amount * (1 - (swap_fee / 100))
    constant_product = base_vault_balance * quote_vault_balance
    updated_quote_vault_balance = constant_product / (base_vault_balance + effective_tokens_sold)
    sol_received = quote_vault_balance - updated_quote_vault_balance
    return round(sol_received, 9)


# main function to run the code
if __name__ == "__main__":
    # Example usage
    buy_tool = BuyTokenWithSolTool()
    buy_tool.forward("ftNSdLt7wuF9kKz6BxiUVWYWeRYGyt1RgL5sSjCVnJ2", 0.05, 5)


================================================
File: /galadriel/tools/web3/dexscreener.py
================================================
import json
import requests
from galadriel.core_agent import tool


def get_token_list() -> list:
    """Fetch a list of top tokens from DexScreener.

    Retrieves a list of top tokens from DexScreener's token-boosts endpoint
    and extracts their addresses.

    Returns:
        list: A list of dictionaries containing token addresses
              Limited to the first 4 tokens for performance

    Note:
        The endpoint used is DexScreener's token-boosts/top/v1
        Each dictionary in the returned list has the format:
        {"address": "token_address"}
    """
    token_list = []
    response = requests.get("https://api.dexscreener.com/token-boosts/top/v1", timeout=30)

    if response.status_code == 200:
        _data = response.json()
        for token in _data:
            token_list.append({"address": token["tokenAddress"]})
    # return the first 4 tokens
    return token_list[:4]


@tool
def fetch_market_data(dummy: dict) -> str:  # pylint: disable=W0613
    """Fetch detailed market data for top tokens on Solana.

    Retrieves market data for the top tokens from DexScreener and formats
    it as a JSON string. Removes unnecessary data to fit context limits.

    Args:
        dummy (dict): Unused parameter required by tool decorator

    Returns:
        str: JSON string containing market data for top tokens

    Note:
        - Uses get_token_list() to determine which tokens to fetch
        - Removes 'info' and 'url' fields from the response to reduce size
        - Data is fetched from DexScreener's tokens/v1/solana endpoint
    """
    token_list = get_token_list()
    market_data = []
    for token in token_list:
        response = requests.get(f"https://api.dexscreener.com/tokens/v1/solana/{token['address']}", timeout=30)
        if response.status_code == 200:
            _data = response.json()
            # Remove unrelated data to fit the context limit
            if "info" in _data[0]:
                del _data[0]["info"]
            if "url" in _data[0]:
                del _data[0]["url"]
            market_data.append(_data[0])
    return json.dumps(market_data)


@tool
def get_token_profile(task: str) -> str:  # pylint: disable=W0613
    """Fetch the latest token profiles from DexScreener.

    Retrieves detailed profile information for tokens, including chain,
    address, description, and associated links.

    Args:
        task (str): Unused parameter required by tool decorator

    Returns:
        str: A formatted string containing token profile information

    Note:
        - Data is fetched from DexScreener's token-profiles/latest/v1 endpoint
        - Each token profile includes:
            * Chain ID
            * Token address
            * Description
            * Associated links (with type and URL)
        - Invalid or incomplete profiles are skipped
    """

    response = requests.get(
        "https://api.dexscreener.com/token-profiles/latest/v1",
        headers={},
        timeout=30,
    )
    _data = response.json()
    result = ""
    for token in _data:
        try:
            d = "Chain: " + token["chainId"]
            d += ", tokenAddress: " + token["tokenAddress"]
            d += ", description: " + token["description"]
            for link in token["links"]:
                d += f", {link['type']}: {link['url']}"
            result += d + "\n"
        except Exception:
            pass
    return result


@tool
def fetch_market_data_devnet(dummy: dict) -> str:  # pylint: disable=W0613
    """
    Fetches market data for the Solana Devnet.

    Args:
        dummy: A dummy argument to match the required function signature.

    Returns:
        A JSON string containing market data for the Solana Devnet.
    """
    mock_market_data = json.dumps(
        [
            {
                "chainId": "solana",
                "dexId": "raydium",
                "pairAddress": "ftNSdLt7wuF9kKz6BxiUVWYWeRYGyt1RgL5sSjCVnJ2",
                "baseToken": {
                    "address": "ELJKW7qz3DA93K919agEk398kgeY1eGvs2u3GAfV3FLn",
                    "name": "DAIGE DEVNET",
                    "symbol": "DAIGE",
                },
                "quoteToken": {
                    "address": "So11111111111111111111111111111111111111112",
                    "name": "Wrapped SOL",
                    "symbol": "SOL",
                },
                "priceNative": "0.00000007161",
                "priceUsd": "0.00001362",
                "txns": {
                    "m5": {"buys": 0, "sells": 1},
                    "h1": {"buys": 13, "sells": 25},
                    "h6": {"buys": 64, "sells": 126},
                    "h24": {"buys": 11057, "sells": 4767},
                },
                "volume": {"h24": 946578.57, "h6": 8416.05, "h1": 2250.36, "m5": 0},
                "priceChange": {"m5": -0.1, "h1": -30.85, "h6": -29.27, "h24": -87.54},
                "liquidity": {"usd": 13537.61, "base": 496103405, "quote": 35.6157},
                "fdv": 13627,
                "marketCap": 13627,
                "pairCreatedAt": 1739310341000,
                "boosts": {"active": 5000},
            }
        ],
        indent=4,
    )
    return mock_market_data


if __name__ == "__main__":
    data = fetch_market_data(dummy={})
    print(data)


================================================
File: /galadriel/tools/web3/raydium_openbook.py
================================================
"""
Raydium AMM V4 Integration Module

This module provides tools for interacting with Raydium's Automated Market Maker (AMM) V4
on the Solana blockchain. It enables token swaps using SOL as the base currency.

Key Features:
- Buy tokens with SOL
- Sell tokens for SOL
- AMM pool interaction
- Price calculation with slippage protection
"""

# pylint: disable=R0801
import base64
from dataclasses import dataclass
import json
import os
import struct
import time
from typing import Optional
import logging
from solana.rpc.api import Client
from solana.rpc.commitment import Processed, Confirmed
from solana.rpc.types import TokenAccountOpts, TxOpts
from solders.compute_budget import set_compute_unit_limit, set_compute_unit_price  # type: ignore # pylint: disable=E0401
from solders.message import MessageV0  # type: ignore # pylint: disable=E0401
from solders.keypair import Keypair  # type: ignore # pylint: disable=E0401
from solders.pubkey import Pubkey  # type: ignore # pylint: disable=E0401
from solders.signature import Signature  # type: ignore # pylint: disable=E0401
from solders.instruction import AccountMeta, Instruction  # type: ignore # pylint: disable=E0401
from solders.transaction import VersionedTransaction  # type: ignore # pylint: disable=E0401
from solders.system_program import (
    CreateAccountWithSeedParams,
    create_account_with_seed,
)
from spl.token.client import Token
from spl.token.instructions import (
    CloseAccountParams,
    InitializeAccountParams,
    close_account,
    create_associated_token_account,
    get_associated_token_address,
    initialize_account,
)

from construct import (
    Bytes,
    Int64ul,
    Padding,
    BitsInteger,
    BitsSwapped,
    BitStruct,
    Const,
    Flag,
    BytesInteger,
)
from construct import Struct as cStruct

from galadriel.tools.web3.wallet_tool import WalletTool


logger = logging.getLogger(__name__)

UNIT_BUDGET = 150_000
UNIT_PRICE = 1_000_000

# Raydium AMM V4 devnet addresses
RAYDIUM_AMM_V4 = Pubkey.from_string("HWy1jotHpo6UqeQxx49dpYYdQB8wj9Qk9MdxwjLvDHB8")
OPENBOOK_MARKET = Pubkey.from_string("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj")
RAYDIUM_AUTHORITY = Pubkey.from_string("DbQqP6ehDYmeYjcBaMRuA8tAJY1EjDUz9DpwSLjaQqfC")
FEE_DESTINATION_ID = Pubkey.from_string("3XMrhbv989VxAMi3DErLV9eJht1pHppW5LbKxe9fkEFR")

TOKEN_PROGRAM_ID = Pubkey.from_string("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
ACCOUNT_LAYOUT_LEN = 165
WSOL = Pubkey.from_string("So11111111111111111111111111111111111111112")
SOL_DECIMAL = 1e9

client = Client("https://api.devnet.solana.com")  # type: ignore

LIQUIDITY_STATE_LAYOUT_V4 = cStruct(
    "status" / Int64ul,
    "nonce" / Int64ul,
    "orderNum" / Int64ul,
    "depth" / Int64ul,
    "coinDecimals" / Int64ul,
    "pcDecimals" / Int64ul,
    "state" / Int64ul,
    "resetFlag" / Int64ul,
    "minSize" / Int64ul,
    "volMaxCutRatio" / Int64ul,
    "amountWaveRatio" / Int64ul,
    "coinLotSize" / Int64ul,
    "pcLotSize" / Int64ul,
    "minPriceMultiplier" / Int64ul,
    "maxPriceMultiplier" / Int64ul,
    "systemDecimalsValue" / Int64ul,
    "minSeparateNumerator" / Int64ul,
    "minSeparateDenominator" / Int64ul,
    "tradeFeeNumerator" / Int64ul,
    "tradeFeeDenominator" / Int64ul,
    "pnlNumerator" / Int64ul,
    "pnlDenominator" / Int64ul,
    "swapFeeNumerator" / Int64ul,
    "swapFeeDenominator" / Int64ul,
    "needTakePnlCoin" / Int64ul,
    "needTakePnlPc" / Int64ul,
    "totalPnlPc" / Int64ul,
    "totalPnlCoin" / Int64ul,
    "poolOpenTime" / Int64ul,
    "punishPcAmount" / Int64ul,
    "punishCoinAmount" / Int64ul,
    "orderbookToInitTime" / Int64ul,
    "swapCoinInAmount" / BytesInteger(16, signed=False, swapped=True),
    "swapPcOutAmount" / BytesInteger(16, signed=False, swapped=True),
    "swapCoin2PcFee" / Int64ul,
    "swapPcInAmount" / BytesInteger(16, signed=False, swapped=True),
    "swapCoinOutAmount" / BytesInteger(16, signed=False, swapped=True),
    "swapPc2CoinFee" / Int64ul,
    "poolCoinTokenAccount" / Bytes(32),
    "poolPcTokenAccount" / Bytes(32),
    "coinMintAddress" / Bytes(32),
    "pcMintAddress" / Bytes(32),
    "lpMintAddress" / Bytes(32),
    "ammOpenOrders" / Bytes(32),
    "serumMarket" / Bytes(32),
    "serumProgramId" / Bytes(32),
    "ammTargetOrders" / Bytes(32),
    "poolWithdrawQueue" / Bytes(32),
    "poolTempLpTokenAccount" / Bytes(32),
    "ammOwner" / Bytes(32),
    "pnlOwner" / Bytes(32),
)

ACCOUNT_FLAGS_LAYOUT = BitsSwapped(
    BitStruct(
        "initialized" / Flag,
        "market" / Flag,
        "open_orders" / Flag,
        "request_queue" / Flag,
        "event_queue" / Flag,
        "bids" / Flag,
        "asks" / Flag,
        Const(0, BitsInteger(57)),
    )
)

MARKET_STATE_LAYOUT_V3 = cStruct(
    Padding(5),
    "account_flags" / ACCOUNT_FLAGS_LAYOUT,
    "own_address" / Bytes(32),
    "vault_signer_nonce" / Int64ul,
    "base_mint" / Bytes(32),
    "quote_mint" / Bytes(32),
    "base_vault" / Bytes(32),
    "base_deposits_total" / Int64ul,
    "base_fees_accrued" / Int64ul,
    "quote_vault" / Bytes(32),
    "quote_deposits_total" / Int64ul,
    "quote_fees_accrued" / Int64ul,
    "quote_dust_threshold" / Int64ul,
    "request_queue" / Bytes(32),
    "event_queue" / Bytes(32),
    "bids" / Bytes(32),
    "asks" / Bytes(32),
    "base_lot_size" / Int64ul,
    "quote_lot_size" / Int64ul,
    "fee_rate_bps" / Int64ul,
    "referrer_rebate_accrued" / Int64ul,
    Padding(7),
)


@dataclass
class AmmV4PoolKeys:
    """Data structure for Raydium AMM V4 pool configuration.

    Contains all necessary public keys and parameters for interacting
    with a Raydium AMM V4 pool.

    Attributes:
        amm_id (Pubkey): The AMM pool's public key
        base_mint (Pubkey): Base token mint address
        quote_mint (Pubkey): Quote token mint address
        base_decimals (int): Base token decimal places
        quote_decimals (int): Quote token decimal places
        open_orders (Pubkey): OpenBook open orders account
        target_orders (Pubkey): Target orders account
        base_vault (Pubkey): Base token vault
        quote_vault (Pubkey): Quote token vault
        market_id (Pubkey): OpenBook market ID
        market_authority (Pubkey): Market authority account
        market_base_vault (Pubkey): Market base token vault
        market_quote_vault (Pubkey): Market quote token vault
        bids (Pubkey): Market bids account
        asks (Pubkey): Market asks account
        event_queue (Pubkey): Market event queue
        ray_authority_v4 (Pubkey): Raydium authority account
        open_book_program (Pubkey): OpenBook program ID
        token_program_id (Pubkey): Token program ID
    """

    amm_id: Pubkey
    base_mint: Pubkey
    quote_mint: Pubkey
    base_decimals: int
    quote_decimals: int
    open_orders: Pubkey
    target_orders: Pubkey
    base_vault: Pubkey
    quote_vault: Pubkey
    market_id: Pubkey
    market_authority: Pubkey
    market_base_vault: Pubkey
    market_quote_vault: Pubkey
    bids: Pubkey
    asks: Pubkey
    event_queue: Pubkey
    ray_authority_v4: Pubkey
    open_book_program: Pubkey
    token_program_id: Pubkey


class BuyTokenWithSolTool(WalletTool):
    """Tool for buying tokens using SOL on Raydium AMM V4.

    Enables users to swap SOL for any token available on Raydium AMM V4.
    Handles account creation, token swaps, and cleanup of temporary accounts.

    Attributes:
        name (str): Tool identifier
        description (str): Description of the tool's functionality
        inputs (dict): Schema for required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = "buy_token_with_sol"
    description = "Buy a token with SOL using the Raydium AMM V4."
    inputs = {
        "pair_address": {
            "type": "string",
            "description": "The address of the AMM V4 pair",
        },
        "sol_in": {
            "type": "number",
            "description": "The amount of SOL to swap",
            "default": 0.01,
            "nullable": True,
        },
        "slippage": {
            "type": "integer",
            "description": "The slippage tolerance percentage",
            "default": 5,
            "nullable": True,
        },
    }
    output_type = "string"

    def forward(self, pair_address: str, sol_in: float = 0.01, slippage: int = 5) -> str:  # pylint: disable=W0221
        """Execute a SOL to token swap transaction.

        Args:
            pair_address (str): The Raydium AMM V4 pair address
            sol_in (float, optional): Amount of SOL to swap. Defaults to 0.01
            slippage (int, optional): Slippage tolerance percentage. Defaults to 5

        Returns:
            str: Transaction result message with signature
        """
        payer_keypair = self.wallet_repository.get_wallet()
        result = buy(payer_keypair, pair_address, sol_in, slippage)
        return result


class SellTokenForSolTool(WalletTool):
    """Tool for selling tokens for SOL on Raydium AMM V4.

    Enables users to swap any token for SOL using Raydium AMM V4.
    Handles account management and token swaps with slippage protection.

    Attributes:
        name (str): Tool identifier
        description (str): Description of the tool's functionality
        inputs (dict): Schema for required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = "sell_token_for_sol"
    description = "Sell a token for SOL using the Raydium AMM V4."
    inputs = {
        "pair_address": {
            "type": "string",
            "description": "The address of the AMM V4 pair",
        },
        "percentage": {
            "type": "integer",
            "description": "The percentage of token to sell",
            "default": 100,
        },
        "slippage": {
            "type": "integer",
            "description": "The slippage tolerance percentage",
            "default": 5,
        },
    }
    output_type = "string"

    def forward(self, pair_address: str, percentage: int = 100, slippage: int = 5) -> str:  # pylint: disable=W0221
        """Execute a token to SOL swap transaction.

        Args:
            pair_address (str): The Raydium AMM V4 pair address
            percentage (int, optional): Percentage of token balance to sell. Defaults to 100
            slippage (int, optional): Slippage tolerance percentage. Defaults to 5

        Returns:
            str: Transaction result message with signature
        """
        payer_keypair = self.wallet_repository.get_wallet()
        result = sell(payer_keypair, pair_address, percentage, slippage)
        return result


# pylint: disable=R0914
def buy(payer_keypair: Keypair, pair_address: str, sol_in: float = 0.01, slippage: int = 5) -> str:
    """Buy tokens with SOL using Raydium AMM V4.

    Creates necessary token accounts, executes the swap, and handles cleanup
    of temporary accounts.

    Args:
        payer_keypair (Keypair): The transaction signer's keypair
        pair_address (str): The Raydium AMM V4 pair address
        sol_in (float, optional): Amount of SOL to swap. Defaults to 0.01
        slippage (int, optional): Slippage tolerance percentage. Defaults to 5

    Returns:
        str: Transaction result message

    Note:
        - Creates temporary WSOL account for swap
        - Creates token account if needed
        - Handles account cleanup after swap
        - Includes slippage protection
    """
    try:
        pool_keys: Optional[AmmV4PoolKeys] = fetch_amm_v4_pool_keys(pair_address)
        if pool_keys is None:
            return "Failed to fetch pool keys."

        mint = pool_keys.base_mint if pool_keys.base_mint != WSOL else pool_keys.quote_mint
        amount_in = int(sol_in * SOL_DECIMAL)

        base_reserve, quote_reserve, token_decimal = get_amm_v4_reserves(pool_keys)
        amount_out = sol_for_tokens(sol_in, base_reserve, quote_reserve)

        slippage_adjustment = 1 - (slippage / 100)
        amount_out_with_slippage = amount_out * slippage_adjustment
        minimum_amount_out = int(amount_out_with_slippage * 10**token_decimal)

        token_account_check = client.get_token_accounts_by_owner(
            payer_keypair.pubkey(), TokenAccountOpts(mint), Processed
        )
        if token_account_check.value:
            token_account = token_account_check.value[0].pubkey
            create_token_account_instruction = None
        else:
            token_account = get_associated_token_address(payer_keypair.pubkey(), mint)
            create_token_account_instruction = create_associated_token_account(
                payer_keypair.pubkey(), payer_keypair.pubkey(), mint
            )

        seed = base64.urlsafe_b64encode(os.urandom(24)).decode("utf-8")
        wsol_token_account = Pubkey.create_with_seed(payer_keypair.pubkey(), seed, TOKEN_PROGRAM_ID)
        balance_needed = Token.get_min_balance_rent_for_exempt_for_account(client)

        create_wsol_account_instruction = create_account_with_seed(
            CreateAccountWithSeedParams(
                from_pubkey=payer_keypair.pubkey(),
                to_pubkey=wsol_token_account,
                base=payer_keypair.pubkey(),
                seed=seed,
                lamports=int(balance_needed + amount_in),
                space=ACCOUNT_LAYOUT_LEN,
                owner=TOKEN_PROGRAM_ID,
            )
        )

        init_wsol_account_instruction = initialize_account(
            InitializeAccountParams(
                program_id=TOKEN_PROGRAM_ID,
                account=wsol_token_account,
                mint=WSOL,
                owner=payer_keypair.pubkey(),
            )
        )

        swap_instruction = make_amm_v4_swap_instruction(
            amount_in=amount_in,
            minimum_amount_out=minimum_amount_out,
            token_account_in=wsol_token_account,
            token_account_out=token_account,
            accounts=pool_keys,
            owner=payer_keypair.pubkey(),
        )

        close_wsol_account_instruction = close_account(
            CloseAccountParams(
                program_id=TOKEN_PROGRAM_ID,
                account=wsol_token_account,
                dest=payer_keypair.pubkey(),
                owner=payer_keypair.pubkey(),
            )
        )

        instructions = [
            set_compute_unit_limit(UNIT_BUDGET),
            set_compute_unit_price(UNIT_PRICE),
            create_wsol_account_instruction,
            init_wsol_account_instruction,
        ]

        if create_token_account_instruction:
            instructions.append(create_token_account_instruction)

        instructions.append(swap_instruction)  # type: ignore
        instructions.append(close_wsol_account_instruction)

        compiled_message = MessageV0.try_compile(
            payer_keypair.pubkey(),
            instructions,
            [],
            client.get_latest_blockhash().value.blockhash,
        )

        txn_sig = client.send_transaction(
            txn=VersionedTransaction(compiled_message, [payer_keypair]),
            opts=TxOpts(skip_preflight=False),
        ).value

        confirmed = confirm_txn(txn_sig)

        if confirmed:
            return f"Transaction successful. Signature: {txn_sig}"
        return "Transaction failed. Confirmation timeout."

    except Exception as e:
        return f"Error occurred during transaction: {e}"


def sell(payer_keypair: Keypair, pair_address: str, percentage: int = 100, slippage: int = 5) -> str:
    """Sell tokens for SOL using Raydium AMM V4.

    Swaps specified percentage of token balance for SOL with slippage protection.

    Args:
        payer_keypair (Keypair): The transaction signer's keypair
        pair_address (str): The Raydium AMM V4 pair address
        percentage (int, optional): Percentage of token balance to sell. Defaults to 100
        slippage (int, optional): Slippage tolerance percentage. Defaults to 5

    Returns:
        str: Transaction result message

    Note:
        - Creates temporary WSOL account for swap
        - Optionally closes token account if selling 100%
        - Includes slippage protection
    """
    try:
        if not 1 <= percentage <= 100:
            return "Percentage must be between 1 and 100."

        pool_keys: Optional[AmmV4PoolKeys] = fetch_amm_v4_pool_keys(pair_address)
        if pool_keys is None:
            return "Failed to fetch pool keys."

        mint = pool_keys.base_mint if pool_keys.base_mint != WSOL else pool_keys.quote_mint
        token_balance = get_token_balance(payer_keypair.pubkey(), str(mint))

        if token_balance == 0 or token_balance is None:
            return "No token balance available to sell."

        token_balance = token_balance * (percentage / 100)
        base_reserve, quote_reserve, token_decimal = get_amm_v4_reserves(pool_keys)
        amount_out = tokens_for_sol(token_balance, base_reserve, quote_reserve)

        slippage_adjustment = 1 - (slippage / 100)
        amount_out_with_slippage = amount_out * slippage_adjustment
        minimum_amount_out = int(amount_out_with_slippage * SOL_DECIMAL)

        amount_in = int(token_balance * 10**token_decimal)
        token_account = get_associated_token_address(payer_keypair.pubkey(), mint)

        seed = base64.urlsafe_b64encode(os.urandom(24)).decode("utf-8")
        wsol_token_account = Pubkey.create_with_seed(payer_keypair.pubkey(), seed, TOKEN_PROGRAM_ID)
        balance_needed = Token.get_min_balance_rent_for_exempt_for_account(client)

        create_wsol_account_instruction = create_account_with_seed(
            CreateAccountWithSeedParams(
                from_pubkey=payer_keypair.pubkey(),
                to_pubkey=wsol_token_account,
                base=payer_keypair.pubkey(),
                seed=seed,
                lamports=int(balance_needed),
                space=ACCOUNT_LAYOUT_LEN,
                owner=TOKEN_PROGRAM_ID,
            )
        )

        init_wsol_account_instruction = initialize_account(
            InitializeAccountParams(
                program_id=TOKEN_PROGRAM_ID,
                account=wsol_token_account,
                mint=WSOL,
                owner=payer_keypair.pubkey(),
            )
        )

        swap_instructions = make_amm_v4_swap_instruction(
            amount_in=amount_in,
            minimum_amount_out=minimum_amount_out,
            token_account_in=token_account,
            token_account_out=wsol_token_account,
            accounts=pool_keys,
            owner=payer_keypair.pubkey(),
        )

        close_wsol_account_instruction = close_account(
            CloseAccountParams(
                program_id=TOKEN_PROGRAM_ID,
                account=wsol_token_account,
                dest=payer_keypair.pubkey(),
                owner=payer_keypair.pubkey(),
            )
        )

        instructions = [
            set_compute_unit_limit(UNIT_BUDGET),
            set_compute_unit_price(UNIT_PRICE),
            create_wsol_account_instruction,
            init_wsol_account_instruction,
            swap_instructions,
            close_wsol_account_instruction,
        ]

        if percentage == 100:
            close_token_account_instruction = close_account(
                CloseAccountParams(
                    program_id=TOKEN_PROGRAM_ID,
                    account=token_account,
                    dest=payer_keypair.pubkey(),
                    owner=payer_keypair.pubkey(),
                )
            )
            instructions.append(close_token_account_instruction)

        # Filter out any None instructions
        valid_instructions = [instr for instr in instructions if instr is not None]
        compiled_message = MessageV0.try_compile(
            payer_keypair.pubkey(),
            valid_instructions,
            [],
            client.get_latest_blockhash().value.blockhash,
        )

        txn_sig = client.send_transaction(
            txn=VersionedTransaction(compiled_message, [payer_keypair]),
            opts=TxOpts(skip_preflight=False),
        ).value

        confirmed = confirm_txn(txn_sig)

        if confirmed:
            return f"Transaction successful. Signature: {txn_sig}"
        return "Transaction failed. Confirmation timeout."

    except Exception as e:
        return f"Error occurred during transaction: {e}"


def sol_for_tokens(sol_amount, base_vault_balance, quote_vault_balance, swap_fee=0.25):
    effective_sol_used = sol_amount - (sol_amount * (swap_fee / 100))
    constant_product = base_vault_balance * quote_vault_balance
    updated_base_vault_balance = constant_product / (quote_vault_balance + effective_sol_used)
    tokens_received = base_vault_balance - updated_base_vault_balance
    return round(tokens_received, 9)


def tokens_for_sol(token_amount, base_vault_balance, quote_vault_balance, swap_fee=0.25):
    effective_tokens_sold = token_amount * (1 - (swap_fee / 100))
    constant_product = base_vault_balance * quote_vault_balance
    updated_quote_vault_balance = constant_product / (base_vault_balance + effective_tokens_sold)
    sol_received = quote_vault_balance - updated_quote_vault_balance
    return round(sol_received, 9)


def fetch_amm_v4_pool_keys(pair_address: str) -> Optional[AmmV4PoolKeys]:
    """Fetch pool configuration for a Raydium AMM V4 pair.

    Retrieves and parses pool configuration data from the Solana blockchain.

    Args:
        pair_address (str): The Raydium AMM V4 pair address

    Returns:
        Optional[AmmV4PoolKeys]: Pool configuration if successful, None otherwise

    Note:
        Includes market data from OpenBook integration
    """

    def bytes_of(value):
        if not 0 <= value < 2**64:
            raise ValueError("Value must be in the range of a u64 (0 to 2^64 - 1).")
        return struct.pack("<Q", value)

    try:
        amm_id = Pubkey.from_string(pair_address)
        amm_data = client.get_account_info_json_parsed(amm_id, commitment=Processed).value.data  # type: ignore
        amm_data_decoded = LIQUIDITY_STATE_LAYOUT_V4.parse(amm_data)  # type: ignore
        market_id = Pubkey.from_bytes(amm_data_decoded.serumMarket)
        market_info = client.get_account_info_json_parsed(market_id, commitment=Processed).value.data  # type: ignore
        market_decoded = MARKET_STATE_LAYOUT_V3.parse(market_info)  # type: ignore
        vault_signer_nonce = market_decoded.vault_signer_nonce

        pool_keys = AmmV4PoolKeys(
            amm_id=amm_id,
            base_mint=Pubkey.from_bytes(market_decoded.base_mint),
            quote_mint=Pubkey.from_bytes(market_decoded.quote_mint),
            base_decimals=amm_data_decoded.coinDecimals,
            quote_decimals=amm_data_decoded.pcDecimals,
            open_orders=Pubkey.from_bytes(amm_data_decoded.ammOpenOrders),
            target_orders=Pubkey.from_bytes(amm_data_decoded.ammTargetOrders),
            base_vault=Pubkey.from_bytes(amm_data_decoded.poolCoinTokenAccount),
            quote_vault=Pubkey.from_bytes(amm_data_decoded.poolPcTokenAccount),
            market_id=market_id,
            market_authority=Pubkey.create_program_address(
                seeds=[bytes(market_id), bytes_of(vault_signer_nonce)],
                program_id=OPENBOOK_MARKET,
            ),
            market_base_vault=Pubkey.from_bytes(market_decoded.base_vault),
            market_quote_vault=Pubkey.from_bytes(market_decoded.quote_vault),
            bids=Pubkey.from_bytes(market_decoded.bids),
            asks=Pubkey.from_bytes(market_decoded.asks),
            event_queue=Pubkey.from_bytes(market_decoded.event_queue),
            ray_authority_v4=RAYDIUM_AUTHORITY,
            open_book_program=OPENBOOK_MARKET,
            token_program_id=TOKEN_PROGRAM_ID,
        )

        return pool_keys
    except Exception as e:
        logger.error(f"Error fetching pool keys: {e}")
        return None


def get_amm_v4_reserves(pool_keys: AmmV4PoolKeys) -> tuple:
    """Get current token reserves from AMM pool.

    Fetches current balances of both tokens in the pool.

    Args:
        pool_keys (AmmV4PoolKeys): Pool configuration data

    Returns:
        tuple: (base_reserve, quote_reserve, token_decimal)

    Note:
        Handles WSOL wrapping/unwrapping automatically
    """
    try:
        quote_vault = pool_keys.quote_vault
        quote_decimal = pool_keys.quote_decimals
        quote_mint = pool_keys.quote_mint

        base_vault = pool_keys.base_vault
        base_decimal = pool_keys.base_decimals
        base_mint = pool_keys.base_mint

        balances_response = client.get_multiple_accounts_json_parsed([quote_vault, base_vault], Processed)
        balances = balances_response.value

        quote_account = balances[0]
        base_account = balances[1]

        quote_account_balance = quote_account.data.parsed["info"]["tokenAmount"]["uiAmount"]  # type: ignore
        base_account_balance = base_account.data.parsed["info"]["tokenAmount"]["uiAmount"]  # type: ignore

        if quote_account_balance is None or base_account_balance is None:
            logger.error("Error: One of the account balances is None.")
            return None, None, None

        if base_mint == WSOL:
            base_reserve = quote_account_balance
            quote_reserve = base_account_balance
            token_decimal = quote_decimal
        else:
            base_reserve = base_account_balance
            quote_reserve = quote_account_balance
            token_decimal = base_decimal

        logger.info(f"Base Mint: {base_mint} | Quote Mint: {quote_mint}")
        logger.info(f"Base Reserve: {base_reserve} | Quote Reserve: {quote_reserve} | Token Decimal: {token_decimal}")
        return base_reserve, quote_reserve, token_decimal

    except Exception as e:
        logger.error(f"Error occurred: {e}")
        return None, None, None


# pylint: disable=R0917
def make_amm_v4_swap_instruction(
    amount_in: int,
    minimum_amount_out: int,
    token_account_in: Pubkey,
    token_account_out: Pubkey,
    accounts: AmmV4PoolKeys,
    owner: Pubkey,
) -> Optional[Instruction]:
    """Create swap instruction for Raydium AMM V4.

    Constructs the instruction for executing a token swap.

    Args:
        amount_in (int): Input token amount in raw units
        minimum_amount_out (int): Minimum acceptable output amount
        token_account_in (Pubkey): Source token account
        token_account_out (Pubkey): Destination token account
        accounts (AmmV4PoolKeys): Pool configuration
        owner (Pubkey): Transaction signer's public key

    Returns:
        Optional[Instruction]: Swap instruction if successful, None otherwise

    Note:
        Includes all necessary account metas for the swap
    """
    try:
        keys = [
            AccountMeta(pubkey=accounts.token_program_id, is_signer=False, is_writable=False),
            AccountMeta(pubkey=accounts.amm_id, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.ray_authority_v4, is_signer=False, is_writable=False),
            AccountMeta(pubkey=accounts.open_orders, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.target_orders, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.base_vault, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.quote_vault, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.open_book_program, is_signer=False, is_writable=False),
            AccountMeta(pubkey=accounts.market_id, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.bids, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.asks, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.event_queue, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.market_base_vault, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.market_quote_vault, is_signer=False, is_writable=True),
            AccountMeta(pubkey=accounts.market_authority, is_signer=False, is_writable=False),
            AccountMeta(pubkey=token_account_in, is_signer=False, is_writable=True),
            AccountMeta(pubkey=token_account_out, is_signer=False, is_writable=True),
            AccountMeta(pubkey=owner, is_signer=True, is_writable=False),
        ]

        data = bytearray()
        discriminator = 9
        data.extend(struct.pack("<B", discriminator))
        data.extend(struct.pack("<Q", amount_in))
        data.extend(struct.pack("<Q", minimum_amount_out))
        swap_instruction = Instruction(RAYDIUM_AMM_V4, bytes(data), keys)

        return swap_instruction
    except Exception as e:
        logger.error(f"Error occurred: {e}")
        return None


def get_token_balance(pubkey: Pubkey, mint_str: str) -> float | None:
    """Get the balance of a token for a given address.

    Args:
        pubkey (Pubkey): The address to get the token balance for
        mint_str (str): The mint address of the token

    Returns:
        float | None: The balance of the token if successful, None otherwise
    """
    mint = Pubkey.from_string(mint_str)
    response = client.get_token_accounts_by_owner_json_parsed(pubkey, TokenAccountOpts(mint=mint), commitment=Processed)

    if response.value:
        accounts = response.value
        if accounts:
            try:
                token_amount = accounts[0].account.data.parsed["info"]["tokenAmount"]["uiAmount"]  # type: ignore
                if isinstance(token_amount, (int, float, str)):
                    return float(token_amount)
            except Exception as e:
                logger.error(f"Failed to parse token amount: {e}")
                return None
    return None


def confirm_txn(txn_sig: Signature, max_retries: int = 20, retry_interval: int = 3) -> bool:
    """Confirm a transaction.

    Args:
        txn_sig (Signature): The signature of the transaction
        max_retries (int, optional): Maximum number of retries. Defaults to 20
        retry_interval (int, optional): Interval between retries in seconds. Defaults to 3

    Returns:
        bool: True if transaction is confirmed, False otherwise
    """
    retries = 1

    while retries < max_retries:
        try:
            txn_res = client.get_transaction(
                txn_sig,
                encoding="json",
                commitment=Confirmed,
                max_supported_transaction_version=0,
            )
            if txn_res.value and txn_res.value.transaction.meta:
                txn_json = json.loads(txn_res.value.transaction.meta.to_json())
            else:
                return False

            if txn_json["err"] is None:
                logger.info("Transaction confirmed... try count:", retries)
                return True

            logger.error("Error: Transaction not confirmed. Retrying...")
            if txn_json["err"]:
                logger.error("Transaction failed.")
                return False
        except Exception:
            logger.info("Awaiting confirmation... try count:", retries)
            retries += 1
            time.sleep(retry_interval)

    logger.error("Max retries reached. Transaction confirmation failed.")
    return False


# main function to run the code
if __name__ == "__main__":
    # buy_token
    buy_token_with_sol_tool = BuyTokenWithSolTool()
    buy_token_with_sol_tool.forward("FFBvVfBcZ8abyt9dgQ1dS9F49mzNTCQbEpppwE9mcReB", 0.05, 5)


================================================
File: /galadriel/tools/twitter.py
================================================
"""
This module provides tools for interacting with Twitter's API, enabling
posting tweets, searching tweets, retrieving replies, and fetching specific
tweets.

Key Features:
- Post tweets and replies
- Search tweets by query
- Get replies to specific tweets
- Fetch individual tweets by ID

Required Environment Variables:
    TWITTER_CONSUMER_API_KEY: Twitter API consumer key
    TWITTER_CONSUMER_API_SECRET: Twitter API consumer secret
    TWITTER_ACCESS_TOKEN: Twitter access token
    TWITTER_ACCESS_TOKEN_SECRET: Twitter access token secret
"""

import json
import os
from typing import Dict, Optional

from galadriel.core_agent import Tool
from galadriel.connectors.twitter import TwitterApiClient, TwitterCredentials
from galadriel.logging_utils import get_agent_logger

logger = get_agent_logger()

# Tool name constants
TWITTER_POST_TOOL_NAME = "twitter_post_tool"
TWITTER_SEARCH_TOOL_NAME = "twitter_search_tool"
TWITTER_REPLIES_TOOL_NAME = "twitter_replies_tool"
TWITTER_GET_POST_TOOL_NAME = "twitter_get_post_tool"


class CredentialsException(Exception):
    """Exception raised for Twitter credentials issues.

    Raised when required Twitter API credentials are missing or invalid.
    """


class TwitterPostTool(TwitterApiClient, Tool):
    """Tool for posting tweets to Twitter.

    Enables posting new tweets and replies to existing tweets using
    Twitter's API v2.

    Attributes:
        name (str): Tool identifier
        description (str): Description of the tool's functionality
        inputs (dict): Schema for required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = TWITTER_POST_TOOL_NAME
    description = (
        "This is a tool that posts a tweet to twitter. It returns a boolean indicating if the posting was successful."
    )
    inputs = {
        "tweet": {"type": "string", "description": "The tweet to post to twitter"},
        "in_reply_to_id": {
            "type": "string",
            "description": "The tweet ID to respond to, empty string for NOT replying",
        },
    }
    output_type = "object"

    def __init__(self, _credentials: Optional[TwitterCredentials] = None):
        """Initialize the Twitter post tool.

        Args:
            _credentials (Optional[TwitterCredentials]): Twitter API credentials.
                If None, credentials are loaded from environment variables.

        Raises:
            CredentialsException: If required credentials are missing
        """
        if not _credentials:
            credentials = _get_credentials_from_env()
        else:
            credentials = _credentials
        super().__init__(credentials)

    def forward(self, tweet: str, in_reply_to_id: str) -> Dict:  # pylint:disable=W0221
        """Post a tweet or reply to Twitter.

        Args:
            tweet (str): The content of the tweet to post
            in_reply_to_id (str): ID of tweet to reply to, or empty string

        Returns:
            Dict: Response data from Twitter API

        Note:
            Returns empty dict if posting fails
        """
        response = self.post_tweet(tweet, in_reply_to_id)
        return response or {}


class TwitterSearchTool(TwitterApiClient, Tool):
    """Tool for searching tweets on Twitter.

    Enables searching for tweets using Twitter's API v2 search functionality.

    Attributes:
        name (str): Tool identifier
        description (str): Description of the tool's functionality
        inputs (dict): Schema for required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = TWITTER_SEARCH_TOOL_NAME
    description = "This is a tool that searches tweets. It returns a list of results."
    inputs = {
        "search_query": {
            "type": "string",
            "description": "Search query supported by the Twitter API",
        },
    }
    output_type = "string"

    def __init__(self, _credentials: Optional[TwitterCredentials] = None):
        """Initialize the Twitter search tool.

        Args:
            _credentials (Optional[TwitterCredentials]): Twitter API credentials.
                If None, credentials are loaded from environment variables.

        Raises:
            CredentialsException: If required credentials are missing
        """
        if not _credentials:
            credentials = _get_credentials_from_env()
        else:
            credentials = _credentials
        super().__init__(credentials)

    def forward(self, search_query: str) -> str:  # pylint:disable=W0221
        """Search for tweets matching a query.

        Args:
            search_query (str): The search query to execute

        Returns:
            str: JSON string containing search results
        """
        results = self.search(search_query)
        formatted_results = [r.to_dict() for r in results]
        return json.dumps(formatted_results)


class TwitterRepliesTool(TwitterApiClient, Tool):
    """Tool for retrieving replies to a tweet.

    Enables fetching all replies to a specific tweet using Twitter's API v2.

    Attributes:
        name (str): Tool identifier
        description (str): Description of the tool's functionality
        inputs (dict): Schema for required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = TWITTER_REPLIES_TOOL_NAME
    description = "This is a tool that gets replies to a tweet. It returns a list of results."
    inputs = {
        "conversation_id": {
            "type": "string",
            "description": "The conversation ID. It is set after the original tweet ID",
        },
    }
    output_type = "string"

    def __init__(self, _credentials: Optional[TwitterCredentials] = None):
        """Initialize the Twitter replies tool.

        Args:
            _credentials (Optional[TwitterCredentials]): Twitter API credentials.
                If None, credentials are loaded from environment variables.

        Raises:
            CredentialsException: If required credentials are missing
        """
        if not _credentials:
            credentials = _get_credentials_from_env()
        else:
            credentials = _credentials
        super().__init__(credentials)

    def forward(self, conversation_id: str) -> str:  # pylint:disable=W0221
        """Fetch replies to a specific tweet.

        Args:
            conversation_id (str): ID of the conversation to fetch replies from

        Returns:
            str: JSON string containing reply tweets
        """
        results = self.get_replies(conversation_id)
        formatted_results = [r.to_dict() for r in results]
        return json.dumps(formatted_results)


class TwitterGetPostTool(TwitterApiClient, Tool):
    """Tool for retrieving a specific tweet by ID.

    Enables fetching a single tweet's content and metadata using Twitter's API v2.

    Attributes:
        name (str): Tool identifier
        description (str): Description of the tool's functionality
        inputs (dict): Schema for required input parameters
        output_type (str): Type of data returned by the tool
    """

    name = TWITTER_GET_POST_TOOL_NAME
    description = (
        "This is a tool that gets a specific twitter post by its' ID. "
        "If the ID is wrong it will return an empty string."
    )
    inputs = {
        "tweet_id": {
            "type": "string",
            "description": "The tweet ID.",
        },
    }
    output_type = "string"

    def __init__(self, _credentials: Optional[TwitterCredentials] = None):
        """Initialize the Twitter get post tool.

        Args:
            _credentials (Optional[TwitterCredentials]): Twitter API credentials.
                If None, credentials are loaded from environment variables.

        Raises:
            CredentialsException: If required credentials are missing
        """
        if not _credentials:
            credentials = _get_credentials_from_env()
        else:
            credentials = _credentials
        super().__init__(credentials)

    def forward(self, tweet_id: str) -> str:  # pylint:disable=W0221
        """Fetch a specific tweet by ID.

        Args:
            tweet_id (str): The ID of the tweet to fetch

        Returns:
            str: JSON string containing tweet data, or empty string if not found
        """
        result = self.get_tweet(tweet_id)
        if not result:
            return ""
        formatted_result = result.to_dict()
        return json.dumps(formatted_result)


def _get_credentials_from_env() -> TwitterCredentials:
    """Get Twitter API credentials from environment variables.

    Returns:
        TwitterCredentials: Credentials object containing API keys and tokens

    Raises:
        CredentialsException: If any required credentials are missing

    Note:
        Required environment variables:
        - TWITTER_CONSUMER_API_KEY
        - TWITTER_CONSUMER_API_SECRET
        - TWITTER_ACCESS_TOKEN
        - TWITTER_ACCESS_TOKEN_SECRET
    """
    if (
        not os.getenv("TWITTER_CONSUMER_API_KEY")
        or not os.getenv("TWITTER_CONSUMER_API_SECRET")
        or not os.getenv("TWITTER_ACCESS_TOKEN")
        or not os.getenv("TWITTER_ACCESS_TOKEN_SECRET")
    ):
        raise CredentialsException("Missing Twitter environment variables")
    return TwitterCredentials(
        consumer_api_key=os.getenv("TWITTER_CONSUMER_API_KEY", ""),
        consumer_api_secret=os.getenv("TWITTER_CONSUMER_API_SECRET", ""),
        access_token=os.getenv("TWITTER_ACCESS_TOKEN", ""),
        access_token_secret=os.getenv("TWITTER_ACCESS_TOKEN_SECRET", ""),
    )


================================================
File: /galadriel/core_agent.py
================================================
# pylint:disable=W0614,W0401
from smolagents import *

# pylint:disable=W0614,W0611
from smolagents.agents import LogLevel  # noqa: F401
from smolagents.tools import Tool, tool  # noqa: F401


================================================
File: /galadriel/serializable.py
================================================
import contextlib
from abc import ABC
from typing import (
    Any,
    Literal,
    Optional,
    TypedDict,
    Union,
    cast,
)

from pydantic import BaseModel, ConfigDict
from pydantic.fields import FieldInfo
from typing_extensions import NotRequired


class BaseSerialized(TypedDict):
    """Base class for serialized objects.

    Parameters:
        lc: The version of the serialization format.
        id: The unique identifier of the object.
        name: The name of the object. Optional.
        graph: The graph of the object. Optional.
    """

    lc: int
    id: list[str]
    name: NotRequired[str]
    graph: NotRequired[dict[str, Any]]


class SerializedConstructor(BaseSerialized):
    """Serialized constructor.

    Parameters:
        type: The type of the object. Must be "constructor".
        kwargs: The constructor arguments.
    """

    type: Literal["constructor"]
    kwargs: dict[str, Any]


class SerializedSecret(BaseSerialized):
    """Serialized secret.

    Parameters:
        type: The type of the object. Must be "secret".
    """

    type: Literal["secret"]


class SerializedNotImplemented(BaseSerialized):
    """Serialized not implemented.

    Parameters:
        type: The type of the object. Must be "not_implemented".
        repr: The representation of the object. Optional.
    """

    type: Literal["not_implemented"]
    repr: Optional[str]


def try_neq_default(value: Any, key: str, model: BaseModel) -> bool:
    """Try to determine if a value is different from the default.

    Args:
        value: The value.
        key: The key.
        model: The pydantic model.

    Returns:
        Whether the value is different from the default.

    Raises:
        Exception: If the key is not in the model.
    """
    field = model.model_fields[key]
    return _try_neq_default(value, field)


def _try_neq_default(value: Any, field: FieldInfo) -> bool:
    # Handle edge case: inequality of two objects does not evaluate to a bool (e.g. two
    # Pandas DataFrames).
    try:
        return bool(field.get_default() != value)
    except Exception:
        try:
            return all(field.get_default() != value)
        except Exception:
            try:
                return value is not field.default
            except Exception:
                return False


class Serializable(BaseModel, ABC):
    """Serializable base class.

    This class is used to serialize objects to JSON.

    It relies on the following methods and properties:

    - `is_lc_serializable`: Is this class serializable?
        By design, even if a class inherits from Serializable, it is not serializable by
        default. This is to prevent accidental serialization of objects that should not
        be serialized.
    - `get_lc_namespace`: Get the namespace of the langchain object.
        During deserialization, this namespace is used to identify
        the correct class to instantiate.
        Please see the `Reviver` class in `langchain_core.load.load` for more details.
        During deserialization an additional mapping is handle
        classes that have moved or been renamed across package versions.
    - `lc_secrets`: A map of constructor argument names to secret ids.
    - `lc_attributes`: List of additional attribute names that should be included
        as part of the serialized representation.
    """

    # Remove default BaseModel init docstring.
    # pylint: disable=W0246
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        """"""
        super().__init__(*args, **kwargs)

    @classmethod
    def is_lc_serializable(cls) -> bool:
        """Is this class serializable?

        By design, even if a class inherits from Serializable, it is not serializable by
        default. This is to prevent accidental serialization of objects that should not
        be serialized.

        Returns:
            Whether the class is serializable. Default is False.
        """
        return False

    @classmethod
    def get_lc_namespace(cls) -> list[str]:
        """Get the namespace of the langchain object.

        For example, if the class is `langchain.llms.openai.OpenAI`, then the
        namespace is ["langchain", "llms", "openai"]
        """
        return cls.__module__.split(".")

    @property
    def lc_secrets(self) -> dict[str, str]:
        """A map of constructor argument names to secret ids.

        For example,
            {"openai_api_key": "OPENAI_API_KEY"}
        """
        return {}

    @property
    def lc_attributes(self) -> dict:
        """List of attribute names that should be included in the serialized kwargs.

        These attributes must be accepted by the constructor.
        Default is an empty dictionary.
        """
        return {}

    @classmethod
    def lc_id(cls) -> list[str]:
        """A unique identifier for this class for serialization purposes.

        The unique identifier is a list of strings that describes the path
        to the object.
        For example, for the class `langchain.llms.openai.OpenAI`, the id is
        ["langchain", "llms", "openai", "OpenAI"].
        """
        # Pydantic generics change the class name. So we need to do the following
        if "origin" in cls.__pydantic_generic_metadata__ and cls.__pydantic_generic_metadata__["origin"] is not None:
            original_name = cls.__pydantic_generic_metadata__["origin"].__name__
        else:
            original_name = cls.__name__
        return [*cls.get_lc_namespace(), original_name]

    model_config = ConfigDict(
        extra="ignore",
    )

    def __repr_args__(self) -> Any:
        return [
            (k, v) for k, v in super().__repr_args__() if (k not in self.model_fields or try_neq_default(v, k, self))
        ]

    # pylint: disable=R0912
    def to_json(self) -> Union[SerializedConstructor, SerializedNotImplemented]:
        """Serialize the object to JSON.

        Returns:
            A json serializable object or a SerializedNotImplemented object.
        """
        if not self.is_lc_serializable():
            return self.to_json_not_implemented()

        secrets = {}
        # Get latest values for kwargs if there is an attribute with same name
        lc_kwargs = {}
        for k, v in self:
            if not _is_field_useful(self, k, v):
                continue
            # Do nothing if the field is excluded
            if k in self.model_fields and self.model_fields[k].exclude:
                continue

            lc_kwargs[k] = getattr(self, k, v)

        # Merge the lc_secrets and lc_attributes from every class in the MRO
        for cls in [None, *self.__class__.mro()]:
            # Once we get to Serializable, we're done
            if cls is Serializable:
                break

            if cls:
                deprecated_attributes = [
                    "lc_namespace",
                    "lc_serializable",
                ]

                for attr in deprecated_attributes:
                    if hasattr(cls, attr):
                        msg = (
                            f"Class {self.__class__} has a deprecated "
                            f"attribute {attr}. Please use the corresponding "
                            f"classmethod instead."
                        )
                        raise ValueError(msg)

            # Get a reference to self bound to each class in the MRO
            this = cast(Serializable, self if cls is None else super(cls, self))

            secrets.update(this.lc_secrets)
            # Now also add the aliases for the secrets
            # This ensures known secret aliases are hidden.
            # Note: this does NOT hide any other extra kwargs
            # that are not present in the fields.
            for key in list(secrets):
                value = secrets[key]
                if key in this.model_fields:
                    alias = this.model_fields[key].alias
                    if alias is not None:
                        secrets[alias] = value
            lc_kwargs.update(this.lc_attributes)

        # include all secrets, even if not specified in kwargs
        # as these secrets may be passed as an environment variable instead
        for key in secrets:
            secret_value = getattr(self, key, None) or lc_kwargs.get(key)
            if secret_value is not None:
                lc_kwargs.update({key: secret_value})

        return {
            "lc": 1,
            "type": "constructor",
            "id": self.lc_id(),
            "kwargs": (lc_kwargs if not secrets else _replace_secrets(lc_kwargs, secrets)),
        }

    def to_json_not_implemented(self) -> SerializedNotImplemented:
        return to_json_not_implemented(self)


def _is_field_useful(inst: Serializable, key: str, value: Any) -> bool:
    """Check if a field is useful as a constructor argument.

    Args:
        inst: The instance.
        key: The key.
        value: The value.

    Returns:
        Whether the field is useful. If the field is required, it is useful.
        If the field is not required, it is useful if the value is not None.
        If the field is not required and the value is None, it is useful if the
        default value is different from the value.
    """
    field = inst.model_fields.get(key)
    if not field:
        return False

    if field.is_required():
        return True

    # Handle edge case: a value cannot be converted to a boolean (e.g. a
    # Pandas DataFrame).
    try:
        value_is_truthy = bool(value)
    except Exception as _:
        value_is_truthy = False

    if value_is_truthy:
        return True

    # Value is still falsy here!
    if field.default_factory is dict and isinstance(value, dict):
        return False

    # Value is still falsy here!
    if field.default_factory is list and isinstance(value, list):
        return False

    value_neq_default = _try_neq_default(value, field)

    # If value is falsy and does not match the default
    return value_is_truthy or value_neq_default


def _replace_secrets(root: dict[Any, Any], secrets_map: dict[str, str]) -> dict[Any, Any]:
    result = root.copy()
    for path, secret_id in secrets_map.items():
        [*parts, last] = path.split(".")
        current = result
        for part in parts:
            if part not in current:
                break
            current[part] = current[part].copy()
            current = current[part]
        if last in current:
            current[last] = {
                "lc": 1,
                "type": "secret",
                "id": [secret_id],
            }
    return result


def to_json_not_implemented(obj: object) -> SerializedNotImplemented:
    """Serialize a "not implemented" object.

    Args:
        obj: object to serialize.

    Returns:
        SerializedNotImplemented
    """
    _id: list[str] = []
    try:
        if hasattr(obj, "__name__"):
            _id = [*obj.__module__.split("."), obj.__name__]
        elif hasattr(obj, "__class__"):
            _id = [*obj.__class__.__module__.split("."), obj.__class__.__name__]
    except Exception:
        pass

    result: SerializedNotImplemented = {
        "lc": 1,
        "type": "not_implemented",
        "id": _id,
        "repr": None,
    }
    with contextlib.suppress(Exception):
        result["repr"] = repr(obj)
    return result


================================================
File: /galadriel/__init__.py
================================================
from .agent import (
    Agent,
    AgentRuntime,
    CodeAgent,
    ToolCallingAgent,
    AgentInput,
    AgentOutput,
    AgentState,
)

__all__ = [
    "Agent",
    "AgentInput",
    "AgentOutput",
    "AgentState",
    "AgentRuntime",
    "CodeAgent",
    "ToolCallingAgent",
]


================================================
File: /galadriel/storage/s3.py
================================================
from datetime import datetime
from typing import Optional

import boto3
from botocore.exceptions import ClientError

from galadriel.logging_utils import get_agent_logger

logger = get_agent_logger()


class S3Client:
    def __init__(self, bucket_name: str):
        """Initialize S3 client with bucket name.

        Args:
            bucket_name: Name of the S3 bucket to use
        """
        self.s3_client = boto3.client("s3")
        self.bucket_name = bucket_name

    async def upload_file(self, file_path: str, agent_name: str) -> Optional[str]:
        """Upload a file to S3 with timestamp in name.

        Args:
            file_path: Local path of file to upload
            agent_name: Name of the agent uploading the file

        Returns:
            S3 path if successful, None if failed
        """
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{agent_name}_{timestamp}"

            s3_path = f"agents/{agent_name}/{filename}.json"

            self.s3_client.upload_file(file_path, self.bucket_name, s3_path)
            logger.info(f"Successfully uploaded {file_path} to {s3_path}")
            return s3_path

        except ClientError as e:
            logger.error(f"Failed to upload file to S3: {str(e)}")
            return None
        except Exception as e:
            logger.error(f"Unexpected error uploading to S3: {str(e)}")
            return None

    async def download_file(self, s3_path: str, local_path: str) -> bool:
        """Download a file from S3.

        Args:
            s3_path: Path of file in S3 bucket
            local_path: Local path to save downloaded file

        Returns:
            True if successful, False if failed
        """
        try:
            self.s3_client.download_file(self.bucket_name, s3_path, local_path)
            logger.info(f"Successfully downloaded {s3_path} to {local_path}")
            return True

        except ClientError as e:
            logger.error(f"Failed to download file from S3: {str(e)}")
            return False
        except Exception as e:
            logger.error(f"Unexpected error downloading from S3: {str(e)}")
            return False


================================================
File: /galadriel/cli.py
================================================
import json
import os
import re
import subprocess
from pathlib import Path
from typing import Optional
from typing import Tuple

import click
import requests
from dotenv import dotenv_values
from dotenv import load_dotenv

# pylint: disable=import-error
from solders.keypair import Keypair  # type: ignore

API_BASE_URL = "https://api.galadriel.com/v1"
DEFAULT_SOLANA_KEY_PATH = os.path.expanduser("~/secret/.private_key.json")
REQUEST_TIMEOUT = 180  # seconds


@click.group(
    help="""
Galadriel: A CLI tool to create autonomous agents and deploy them to Galadriel L1.

Usage:
  galadriel [resource] [subcommand] [options]

Resources:
  agent     Manage agents (create, update, etc.)

Options:
  -h, --help    Show this help message and exit

For more information about each resource, use:
  galadriel <resource> --help
"""
)
def galadriel():
    pass


@galadriel.group()
def agent():
    """Agent management commands"""


@agent.command()
def init() -> None:
    """Create a new Agent folder template in the current directory."""
    agent_name = ""
    while not agent_name:
        agent_name_input = click.prompt("Enter agent name", type=str)
        agent_name = _sanitize_agent_name(agent_name_input)
        if not agent_name:
            print("Invalid agent name: name should only contain alphanumerical and _ symbols.")

    # docker_username = click.prompt("Enter Docker username", type=str)
    # docker_password = click.prompt("Enter Docker password", hide_input=True, type=str)
    # galadriel_api_key = click.prompt(
    #     "Enter Galadriel API key", hide_input=True, type=str
    # )

    click.echo(f"Creating a new agent template in {os.getcwd()}...")
    try:
        _create_agent_template(agent_name, "", "", "")
        click.echo("Successfully created agent template!")
    except Exception as e:
        click.echo(f"Error creating agent template: {str(e)}", err=True)


@agent.command()
@click.option("--image-name", default="agent", help="Name of the Docker image")
def build(image_name: str) -> None:
    """Build the agent Docker image."""
    try:
        docker_username, _ = _assert_config_files(image_name=image_name)
        _build_image(docker_username=docker_username)
    except subprocess.CalledProcessError as e:
        raise click.ClickException(f"Docker command failed: {str(e)}")
    except Exception as e:
        raise click.ClickException(str(e))


@agent.command()
@click.option("--image-name", default="agent", help="Name of the Docker image")
def publish(image_name: str) -> None:
    """Publish the agent Docker image to the Docker Hub."""
    try:
        docker_username, docker_password = _assert_config_files(image_name=image_name)
        _publish_image(
            image_name=image_name,
            docker_username=docker_username,
            docker_password=docker_password,
        )
    except subprocess.CalledProcessError as e:
        raise click.ClickException(f"Docker command failed: {str(e)}")
    except Exception as e:
        raise click.ClickException(str(e))


@agent.command()
@click.option("--image-name", default="agent", help="Name of the Docker image")
def deploy(image_name: str) -> None:
    """Build, publish and deploy the agent."""
    try:
        docker_username, docker_password = _assert_config_files(image_name=image_name)

        click.echo("Building agent...")
        _build_image(docker_username=docker_username)

        click.echo("Publishing agent...")
        _publish_image(
            image_name=image_name,
            docker_username=docker_username,
            docker_password=docker_password,
        )

        click.echo("Deploying agent...")
        agent_id = _galadriel_deploy(image_name, docker_username)
        if not agent_id:
            raise click.ClickException("Failed to deploy agent")
        click.echo(f"Successfully deployed agent! Agent ID: {agent_id}")
    except Exception as e:
        raise click.ClickException(str(e))


@agent.command()
@click.option("--agent-id", help="ID of the agent to update")
@click.option("--image-name", default="agent", help="Name of the Docker image")
def update(agent_id: str, image_name: str):
    """Update the agent"""
    click.echo(f"Updating agent {agent_id}")
    try:
        docker_username, _ = _assert_config_files(image_name=image_name)
        status = _galadriel_update(image_name=image_name, docker_username=docker_username, agent_id=agent_id)
        if status:
            click.echo(f"Successfully updated agent {agent_id}")
        else:
            raise click.ClickException(f"Failed to update agent {agent_id}")
    except Exception as e:
        raise click.ClickException(str(e))


@agent.command()
@click.option("--agent-id", help="ID of the agent to get state for")
def state(agent_id: str):
    """Get information about a deployed agent from Galadriel platform."""
    try:
        load_dotenv(dotenv_path=Path(".") / ".env", override=True)
        api_key = os.getenv("GALADRIEL_API_KEY")
        if not api_key:
            raise click.ClickException("GALADRIEL_API_KEY not found in environment")

        response = requests.get(
            f"{API_BASE_URL}/agents/{agent_id}",
            headers={
                "Content-Type": "application/json",
                "Authorization": f"Bearer {api_key}",
            },
            timeout=REQUEST_TIMEOUT,
        )

        if not response.status_code == 200:
            click.echo(f"Failed to get agent state with status {response.status_code}: {response.text}")
        click.echo(json.dumps(response.json(), indent=2))
    except Exception as e:
        click.echo(f"Failed to get agent state: {str(e)}")


@agent.command()
def states():
    """Get all agent states"""
    try:
        load_dotenv(dotenv_path=Path(".") / ".env", override=True)
        api_key = os.getenv("GALADRIEL_API_KEY")
        if not api_key:
            raise click.ClickException("GALADRIEL_API_KEY not found in environment")

        response = requests.get(
            f"{API_BASE_URL}/agents/",
            headers={
                "Content-Type": "application/json",
                "Authorization": f"Bearer {api_key}",
            },
            timeout=REQUEST_TIMEOUT,
        )

        if not response.status_code == 200:
            click.echo(f"Failed to get agent state with status {response.status_code}: {response.text}")
        click.echo(json.dumps(response.json(), indent=2))
    except Exception as e:
        click.echo(f"Failed to get agent state: {str(e)}")


@agent.command()
@click.argument("agent_id")
def destroy(agent_id: str):
    """Destroy a deployed agent from Galadriel platform."""
    try:
        load_dotenv(dotenv_path=Path(".") / ".env", override=True)
        api_key = os.getenv("GALADRIEL_API_KEY")
        if not api_key:
            raise click.ClickException("GALADRIEL_API_KEY not found in environment")

        response = requests.delete(
            f"{API_BASE_URL}/agents/{agent_id}",
            headers={
                "Content-Type": "application/json",
                "Authorization": f"Bearer {api_key}",
            },
            timeout=REQUEST_TIMEOUT,
        )

        if response.status_code == 200:
            click.echo(f"Successfully destroyed agent {agent_id}")
        else:
            click.echo(f"Failed to destroy agent with status {response.status_code}: {response.text}")
    except Exception as e:
        click.echo(f"Failed to destroy agent: {str(e)}")


@galadriel.group()
def wallet():
    """Wallet management commands"""


@wallet.command()
@click.option("--path", default=DEFAULT_SOLANA_KEY_PATH, help="Path to save the wallet key file")
def create(path: str):
    """Create a new admin wallet"""
    try:
        pub_key = _create_solana_wallet(path)
        click.echo(f"Successfully created Solana wallet {pub_key} at {path}")
    except Exception as e:
        click.echo(f"Failed to create Solana wallet: {str(e)}")


@wallet.command(name="import")
@click.option("--private-key", help="Private key of the wallet to import in JSON format")
@click.option("--path", help="Path to the wallet key file to import")
def import_wallet(private_key: str, path: str):
    """Import an existing wallet"""
    if not private_key and not path:
        raise click.ClickException("Please provide either --private-key or --path")

    if private_key and path:
        raise click.ClickException("Please provide only one of --private-key or --path")

    # FIXME Disable this check for now
    # Check if the .agents.env file exists
    # if not os.path.exists(".agents.env"):
    #    raise click.ClickException(
    #        "No .agents.env file found in current directory. Please run this command under your project directory."
    #    )

    if private_key:
        # Check if the private key is a valid json
        try:
            json.loads(private_key)
        except json.JSONDecodeError:
            raise click.ClickException("Invalid private key! Please provide a valid JSON array")
        # Save the private key to the default path
        os.makedirs(os.path.dirname(DEFAULT_SOLANA_KEY_PATH), exist_ok=True)
        with open(DEFAULT_SOLANA_KEY_PATH, "w", encoding="utf-8") as file:
            file.write(private_key)
        _update_agent_env_file({"SOLANA_KEY_PATH": DEFAULT_SOLANA_KEY_PATH})

        click.echo("Successfully imported Solana wallet from private key")
    elif path:
        if not os.path.exists(path):
            raise click.ClickException(f"File {path} does not exist")
        _update_agent_env_file({"SOLANA_KEY_PATH": path})

        click.echo(f"Successfully imported Solana wallet from {path}")


def _assert_config_files(image_name: str) -> Tuple[str, str]:
    if not os.path.exists("docker-compose.yml"):
        raise click.ClickException("No docker-compose.yml found in current directory")
    if not os.path.exists(".env"):
        raise click.ClickException("No .env file found in current directory")

    load_dotenv(dotenv_path=Path(".") / ".env", override=True)
    docker_username = os.getenv("DOCKER_USERNAME")
    docker_password = os.getenv("DOCKER_PASSWORD")
    os.environ["IMAGE_NAME"] = image_name  # required for docker-compose.yml
    if not docker_username or not docker_password:
        raise click.ClickException("DOCKER_USERNAME or DOCKER_PASSWORD not found in .env file")
    return docker_username, docker_password


# pylint: disable=W0613
def _create_agent_template(agent_name: str, docker_username: str, docker_password: str, galadriel_api_key: str) -> None:
    """
    Generates the Python code and directory structure for a new Galadriel agent.

    Args:
        agent_name: The name of the agent (e.g., "my_daige").
    """

    # Create directories
    agent_dir = os.path.join(agent_name, "agent")
    # agent_configurator_dir = os.path.join(agent_name, "agent_configurator")
    # docker_dir = os.path.join(agent_name, "docker")
    os.makedirs(agent_dir, exist_ok=True)
    # os.makedirs(agent_configurator_dir, exist_ok=True)
    # os.makedirs(docker_dir)

    # Generate <agent_name>.py
    class_name = "".join(word.capitalize() for word in agent_name.split("_"))
    agent_code = f"""from galadriel import Agent
from galadriel.entities import Message


class {class_name}(Agent):
    async def run(self, request: Message) -> Message:
        # Implement your agent's logic here
        print(f"Running {class_name}")
        return Message(
            content="TODO"
        )
"""
    with open(os.path.join(agent_dir, f"{agent_name}.py"), "w", encoding="utf-8") as f:
        f.write(agent_code)

    # Generate <agent_name>.json
    # initial_data = {
    #     "name": class_name,
    #     "description": "A brief description of your agent",
    #     "prompt": "The initial prompt for the agent",
    #     "tools": [],
    # }
    # with open(
    #     os.path.join(agent_configurator_dir, f"{agent_name}.json"),
    #     "w",
    #     encoding="utf-8",
    # ) as f:
    #     json.dump(initial_data, f, indent=2)

    # generate agent.py
    main_code = f"""import asyncio

from galadriel import AgentOutput
from galadriel import AgentRuntime
from galadriel.clients import Cron
from galadriel.entities import Message

from agent.{agent_name} import {class_name}


class GenericOutput(AgentOutput):

    async def send(self, request: Message, response: Message) -> None:
        print(f"Received response: {{response.content}}")


if __name__ == "__main__":
    {agent_name} = {class_name}()
    agent = AgentRuntime(
        inputs=[Cron(interval_seconds=30)],
        outputs=[GenericOutput()],
        agent={agent_name},
    )
    asyncio.run(agent.run())
"""
    with open(os.path.join(agent_name, "agent.py"), "w", encoding="utf-8") as f:
        f.write(main_code)

    # Generate pyproject.toml
    pyproject_toml = """
[tool.poetry]
name = "agent"
version = "0.1.0"
description = ""
authors = ["Your Name <your.email@example.com>"]

[tool.poetry.dependencies]
python = "^3.10"
galadriel = "^0.0.2"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"
"""
    with open(os.path.join(agent_name, "pyproject.toml"), "w", encoding="utf-8") as f:
        f.write(pyproject_toml)

    # Create .env and .agents.env file in the agent directory
    #     env_content = f"""DOCKER_USERNAME={docker_username}
    # DOCKER_PASSWORD={docker_password}
    # GALADRIEL_API_KEY={galadriel_api_key}"""
    #     with open(os.path.join(agent_name, ".env"), "w", encoding="utf-8") as f:
    #         f.write(env_content)
    agent_env_content = f'AGENT_NAME="{agent_name}"'
    with open(os.path.join(agent_name, ".agents.env"), "w", encoding="utf-8") as f:
        f.write(agent_env_content)

    # copy docker files from sentience/galadriel/docker to user current directory
    # docker_files_dir = os.path.join(os.path.dirname(__file__), "docker")
    # shutil.copy(
    #     os.path.join(os.path.join(os.path.dirname(__file__)), "docker-compose.yml"),
    #     os.path.join(agent_name, "docker-compose.yml"),
    # )
    # shutil.copy(
    #     os.path.join(docker_files_dir, "Dockerfile"),
    #     os.path.join(docker_dir, "Dockerfile"),
    # )
    # shutil.copy(
    #     os.path.join(docker_files_dir, ".dockerignore"),
    #     os.path.join(agent_name, ".dockerignore"),
    # )
    # shutil.copy(
    #     os.path.join(docker_files_dir, "logrotate_logs"),
    #     os.path.join(docker_dir, "logrotate_logs"),
    # )


def _build_image(docker_username: str) -> None:
    """Core logic to build the Docker image."""
    click.echo(f"Building Docker image with tag {docker_username}/{os.environ['IMAGE_NAME']}...")
    subprocess.run(["docker-compose", "build"], check=True)
    click.echo("Successfully built Docker image!")


def _publish_image(image_name: str, docker_username: str, docker_password: str) -> None:
    """Core logic to publish the Docker image to the Docker Hub."""

    # Login to Docker Hub
    click.echo("Logging into Docker Hub...")
    login_process = subprocess.run(
        ["docker", "login", "-u", docker_username, "--password-stdin"],
        input=docker_password.encode(),
        capture_output=True,
        check=False,
    )
    if login_process.returncode != 0:
        raise click.ClickException(f"Docker login failed: {login_process.stderr.decode()}")

    # Create repository if it doesn't exist
    click.echo(f"Creating repository {docker_username}/{image_name} if it doesn't exist...")
    create_repo_url = f"https://hub.docker.com/v2/repositories/{docker_username}/{image_name}"
    token_response = requests.post(
        "https://hub.docker.com/v2/users/login/",
        json={"username": docker_username, "password": docker_password},
        timeout=REQUEST_TIMEOUT,
    )
    if token_response.status_code == 200:
        token = token_response.json()["token"]
        requests.post(
            create_repo_url,
            headers={
                "Content-Type": "application/json",
                "Authorization": f"JWT {token}",
            },
            json={"name": image_name, "is_private": False},
            timeout=REQUEST_TIMEOUT,
        )
    # Push image to Docker Hub
    click.echo(f"Pushing Docker image {docker_username}/{image_name}:latest ...")
    subprocess.run(["docker", "push", f"{docker_username}/{image_name}:latest"], check=True)

    click.echo("Successfully pushed Docker image!")


def _galadriel_deploy(image_name: str, docker_username: str) -> Optional[str]:
    """Deploy agent to Galadriel platform."""

    if not os.path.exists(".agents.env"):
        raise click.ClickException("No .agents.env file found in current directory. Please create one.")

    env_vars = dict(dotenv_values(".agents.env"))

    load_dotenv(dotenv_path=Path(".") / ".env")
    api_key = os.getenv("GALADRIEL_API_KEY")
    if not api_key:
        raise click.ClickException("GALADRIEL_API_KEY not found in environment")

    payload = {
        "name": image_name,
        "docker_image": f"{docker_username}/{image_name}:latest",
        "env_vars": env_vars,
    }
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}",
        "accept": "application/json",
    }
    response = requests.post(
        f"{API_BASE_URL}/agents/",
        json=payload,
        headers=headers,
        timeout=REQUEST_TIMEOUT,
    )

    if response.status_code == 200:
        agent_id = response.json()["agent_id"]
        return agent_id
    error_msg = f"""
Failed to deploy agent:
Status Code: {response.status_code}
Response: {response.text}
Request URL: {response.request.url}
Request Headers: {dict(response.request.headers)}
Request Body: {response.request.body!r}
"""
    click.echo(error_msg)
    return None


def _galadriel_update(image_name: str, docker_username: str, agent_id: str) -> bool:
    """Update agent on Galadriel platform."""

    if not os.path.exists(".agents.env"):
        raise click.ClickException("No .agents.env file found in current directory. Please create one.")

    env_vars = dict(dotenv_values(".agents.env"))

    load_dotenv(dotenv_path=Path(".") / ".env")
    api_key = os.getenv("GALADRIEL_API_KEY")
    if not api_key:
        raise click.ClickException("GALADRIEL_API_KEY not found in environment")

    payload = {
        "name": image_name,
        "docker_image": f"{docker_username}/{image_name}:latest",
        "env_vars": env_vars,
    }
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}",
        "accept": "application/json",
    }
    response = requests.put(
        f"{API_BASE_URL}/agents/{agent_id}",
        json=payload,
        headers=headers,
        timeout=REQUEST_TIMEOUT,
    )

    if response.status_code == 200:
        return True

    error_msg = f"""
Failed to update agent:
Status Code: {response.status_code}
Response: {response.text}
Request URL: {response.request.url}
Request Headers: {dict(response.request.headers)}
Request Body: {response.request.body!r}
"""
    click.echo(error_msg)
    return False


def _sanitize_agent_name(user_input: str) -> str:
    """
    Sanitizes the user input to create a valid folder name.
    Allows only alphanumeric characters and underscores (_).
    Other characters are replaced with underscores.

    :param user_input: The raw folder name input from the user.
    :return: A sanitized string suitable for a folder name.
    """
    sanitized_name = re.sub(r"\W+", "_", user_input)  # Replace non-alphanumeric characters with _
    sanitized_name = sanitized_name.strip("_")  # Remove leading/trailing underscores
    return sanitized_name


def _update_agent_env_file(env_vars: dict) -> None:
    """Update the .agents.env file with the new environment variables."""
    existing_env_vars = dotenv_values(".agents.env")

    # Update existing values or add new ones
    existing_env_vars.update(env_vars)

    agent_env_content = ""
    for key, value in existing_env_vars.items():
        # Wrap the string value in quotes
        if isinstance(value, str):
            value = f'"{value}"'
        agent_env_content += f"\n{key}={value}"

    with open(".agents.env", "w", encoding="utf-8") as f:
        f.write(agent_env_content)


def _create_solana_wallet(path: str) -> str:
    """Create a new Solana wallet and save the private key to a file."""
    # Check if the file already exists to prevent overwriting
    if os.path.exists(path):
        raise click.ClickException(f"File {path} already exists")

    # FIXME Disable this check for now
    # Check if the .agents.env file exists
    # if not os.path.exists(".agents.env"):
    #    raise click.ClickException(
    #        "No .agents.env file found in current directory. Please run this command under your project directory."
    #    )

    # Update the .agents.env file with the new wallet path
    _update_agent_env_file({"SOLANA_KEY_PATH": path})

    keypair = Keypair()
    private_key_json = keypair.to_json()
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as file:
        file.write(private_key_json)

    return str(keypair.pubkey())


================================================
File: /galadriel/agent.py
================================================
import asyncio
from abc import ABC
from abc import abstractmethod
from pathlib import Path
from typing import Dict, List
from typing import Optional
from typing import Set

from pprint import pformat

from dotenv import load_dotenv as _load_dotenv

from smolagents import CodeAgent as InternalCodeAgent
from smolagents import ToolCallingAgent as InternalToolCallingAgent

from galadriel.domain import generate_proof
from galadriel.domain import publish_proof
from galadriel.domain import validate_solana_payment
from galadriel.domain.prompts import format_prompt
from galadriel.entities import Message
from galadriel.entities import Pricing
from galadriel.entities import PushOnlyQueue
from galadriel.errors import PaymentValidationError
from galadriel.logging_utils import init_logging
from galadriel.logging_utils import get_agent_logger

logger = get_agent_logger()

DEFAULT_PROMPT_TEMPLATE = "{{request}}"


class Agent(ABC):
    """Abstract base class defining the interface for all agent implementations.

    This class serves as a contract that all concrete agent implementations must follow.
    """

    @abstractmethod
    async def execute(self, request: Message) -> Message:
        """Process a single request and generate a response.
        The processing can be a single LLM call or involve multiple agentic steps, like CodeAgent.

        Args:
            request (Message): The input message to be processed

        Returns:
            Message: The agent's response message
        """
        raise RuntimeError("Function not implemented")


class AgentInput:
    """Base class for handling input sources to the agent runtime.

    Implementations of this class define how inputs are received and queued
    for processing by the agent.
    """

    async def start(self, queue: PushOnlyQueue) -> None:
        """Begin receiving inputs and pushing them to the processing queue.

        Args:
            queue (PushOnlyQueue): Queue to which input messages should be pushed
        """


class AgentOutput:
    """Base class for handling agent output destinations.

    Implementations of this class define how processed responses are delivered
    to their final destination.
    """

    async def send(self, request: Message, response: Message) -> None:
        """Send a processed response to its destination.

        Args:
            request (Message): The original request that generated the response
            response (Message): The response to be delivered
        """


class AgentState:
    # TODO: knowledge_base: KnowledgeBase
    pass


# pylint:disable=E0102
class CodeAgent(Agent, InternalCodeAgent):
    """
    This class combines the abstract Agent interface with the functionality of an internal
    CodeAgent from the smolagents package. It formats the request using a provided template,
    executes the internal code agent's run method, and returns a response message. Memory is
    kept between requests by default.
    """

    def __init__(
        self,
        prompt_template: Optional[str] = None,
        flush_memory: Optional[bool] = False,
        **kwargs,
    ):
        """Initialize the CodeAgent.

        Args:
            prompt_template (Optional[str]): Template used to format input requests.
                The template should contain {{request}} where the input message should be inserted.
                Example: "Answer the following question: {{request}}"
                If not provided, defaults to "{{request}}"
            flush_memory (Optional[bool]): If True, clears memory between requests. Defaults to False.
            **kwargs: Additional arguments passed to InternalCodeAgent

        Example:
            agent = CodeAgent(
                prompt_template="You are a helpful assistant. Please answer: {{request}}",
                model="gpt-4",
            )
            response = await agent.execute(Message(content="What is Python?"))
        """
        InternalCodeAgent.__init__(self, **kwargs)
        self.prompt_template = prompt_template or DEFAULT_PROMPT_TEMPLATE
        self.flush_memory = flush_memory

    async def execute(self, request: Message) -> Message:
        request_dict = {"request": request.content}
        answer = InternalCodeAgent.run(
            self,
            task=format_prompt.execute(self.prompt_template, request_dict),
            reset=self.flush_memory,  # retain memory
        )
        return Message(
            content=str(answer),
            conversation_id=request.conversation_id,
            additional_kwargs=request.additional_kwargs,
        )


# pylint:disable=E0102
class ToolCallingAgent(Agent, InternalToolCallingAgent):
    """
    Similar to CodeAgent, this class wraps an internal ToolCallingAgent from the smolagents
    package. It formats the request, executes the tool-calling agent, and returns the response.
    Memory is kept between requests by default.
    """

    def __init__(
        self,
        prompt_template: Optional[str] = None,
        flush_memory: Optional[bool] = False,
        **kwargs,
    ):
        """
        Initialize the ToolCallingAgent.

        Args:
            prompt_template (Optional[str]): Template used to format input requests.
                The template should contain {{request}} where the input message should be inserted.
                Example: "Use available tools to answer: {{request}}"
                If not provided, defaults to "{{request}}"
            flush_memory (Optional[bool]): If True, clears memory between requests. Defaults to False.
            **kwargs: Additional arguments passed to InternalToolCallingAgent including available tools

        Example:
            agent = ToolCallingAgent(
                prompt_template="You have access to tools. Please help with: {{request}}",
                model="gpt-4",
            )
            response = await agent.execute(Message(content="What's the weather in Paris?"))
        """
        InternalToolCallingAgent.__init__(self, **kwargs)
        self.prompt_template = prompt_template or DEFAULT_PROMPT_TEMPLATE
        self.flush_memory = flush_memory

    async def execute(self, request: Message) -> Message:
        request_dict = {"request": request.content}
        answer = InternalToolCallingAgent.run(
            self,
            task=format_prompt.execute(self.prompt_template, request_dict),
            reset=self.flush_memory,  # retain memory
        )
        return Message(
            content=str(answer),
            conversation_id=request.conversation_id,
            additional_kwargs=request.additional_kwargs,
        )


class AgentRuntime:
    """Runtime environment for executing agent workflows.

    Manages the lifecycle of agent execution including input processing,
    payment validation, response generation, and output delivery.
    """

    def __init__(
        # pylint:disable=R0917
        self,
        inputs: List[AgentInput],
        outputs: List[AgentOutput],
        agent: Agent,
        pricing: Optional[Pricing] = None,
        debug: bool = False,
        enable_logs: bool = False,
    ):
        """Initialize the AgentRuntime.

        Args:
            inputs (List[AgentInput]): Input sources for the agent
            outputs (List[AgentOutput]): Output destinations for responses
            agent (Agent): The agent implementation to use
            pricing (Optional[Pricing]): Payment configuration if required
            debug (bool): Enable debug mode
            enable_logs (bool): Enable logging
        """
        self.inputs = inputs
        self.outputs = outputs
        self.agent = agent
        self.pricing = pricing
        self.spent_payments: Set[str] = set()
        self.debug = debug
        self.enable_logs = enable_logs

        env_path = Path(".") / ".env"
        _load_dotenv(dotenv_path=env_path)
        # AgentConfig should have some settings for debug?
        if self.enable_logs:
            init_logging(self.debug)

    async def run(self):
        """Start the agent runtime loop.

        Creates an single queue and continuously processes incoming requests.
        Al agent inputs receive the same instance of the queue and append requests to it.
        """
        input_queue = asyncio.Queue()
        push_only_queue = PushOnlyQueue(input_queue)

        for agent_input in self.inputs:
            # Each agent input receives a queue it can push messages to
            asyncio.create_task(agent_input.start(push_only_queue))

        while True:
            # Get the next request from the queue
            request = await input_queue.get()
            # Process the request
            await self._run_request(request)
            # await self.upload_state()

    async def _run_request(self, request: Message):
        """Process a single request through the agent pipeline.

        Handles payment validation, agent execution, and response delivery.

        Args:
            request (Message): The request to process
        """
        response = None
        # Handle payment validation
        if self.pricing:
            try:
                task_and_payment = validate_solana_payment.execute(self.pricing, self.spent_payments, request)
                request.content = task_and_payment.task
            except PaymentValidationError as e:
                response = Message(content=str(e))
        if not response:
            # Run the agent if no errors occurred so far
            response = await self.agent.execute(request)
            if self.debug and self.enable_logs:
                memory = await self._get_memory()
                logger.info(f"Current agent memory: {pformat(memory)}")
        if response:
            # proof = await self._generate_proof(request, response)
            # await self._publish_proof(request, response, proof)
            for output in self.outputs:
                await output.send(request, response)

    async def _get_memory(self) -> List[Dict[str, str]]:
        """Retrieve the current state of the agent's memory.

        Returns:
            List[Dict[str, str]]: The agent's memory in a serializable format
        """
        return self.agent.write_memory_to_messages(summary_mode=True)  # type: ignore

    async def _generate_proof(self, request: Message, response: Message) -> str:
        return generate_proof.execute(request, response)

    async def _publish_proof(self, request: Message, response: Message, proof: str):
        publish_proof.execute(request, response, proof)


================================================
File: /galadriel/errors.py
================================================
class PaymentValidationError(Exception):
    pass


================================================
File: /galadriel/entities.py
================================================
import asyncio
from typing import Dict
from typing import Optional

from pydantic import BaseModel
from pydantic import Field

GALADRIEL_API_BASE_URL = "https://api.galadriel.com/v1"


class Message(BaseModel):
    content: str
    conversation_id: Optional[str] = None
    type: Optional[str] = None
    additional_kwargs: Optional[Dict] = None


class HumanMessage(Message):
    type: str = "human"


class AgentMessage(Message):
    type: str = "agent"


class PushOnlyQueue:
    def __init__(self, queue: asyncio.Queue):
        self._queue = queue

    async def put(self, item: Message):
        await self._queue.put(item)


class Pricing(BaseModel):
    """Represents pricing information for Galadriel Agent.

    Contains the cost in SOL and the agent wallet address for payments.
    """

    cost: float = Field(description="The cost of the task in SOL (Solana native currency)", gt=0)
    wallet_address: str = Field(
        description="The Solana wallet address where payment should be sent",
        min_length=32,
        max_length=44,
    )


================================================
File: /galadriel/domain/logs_exporter.py
================================================
import json
import logging
import os
import threading
import time
from datetime import datetime
from datetime import timezone
from typing import Dict
from typing import List
from typing import Optional
from urllib.parse import urljoin

import requests

from galadriel.entities import GALADRIEL_API_BASE_URL

LOG_EXPORT_INTERVAL_SECONDS = 30
LOG_EXPORT_BATCH_SIZE = 20


class LogsExportHandler(logging.Handler):
    def __init__(
        self,
        logger: logging.Logger,
        export_interval_seconds: int = LOG_EXPORT_INTERVAL_SECONDS,
    ):
        super().__init__()
        self.logger = logger
        self.log_records: List[str] = []
        self.export_interval_seconds = export_interval_seconds

    def run(self):
        threading.Thread(
            target=self._run_export_logs_job,
            daemon=True,
        ).start()

    def emit(self, record):
        log_entry = self.format(record)
        self.log_records.append(log_entry)

    def _run_export_logs_job(self) -> None:
        """
        Blocking function that exports logs every self.export_interval_seconds
        """
        api_key = os.getenv("GALADRIEL_API_KEY")
        agent_instance_id = os.getenv("AGENT_INSTANCE_ID")
        if not api_key:
            self.logger.info("Didn't find GALADRIEL_API_KEY, skipping logs exporting")
            return
        if not agent_instance_id:
            self.logger.info("AGENT_INSTANCE_ID not found, skipping logs exporting")
            return
        while True:
            time.sleep(self.export_interval_seconds)
            formatted_logs = self._format_logs()
            is_export_success = self._export_logs(api_key, agent_instance_id, formatted_logs)
            if is_export_success:
                self.log_records = self.log_records[len(formatted_logs) :]

    def _format_logs(self) -> List[Dict]:
        logs = self.log_records[:]  # shallow copy
        formatted_logs = []
        for log in logs:
            try:
                log_line = json.loads(log)
                if log_line.get("message"):
                    formatted_logs.append(
                        {
                            "text": log_line["message"],
                            "level": str(log_line.get("levelname", "info")).lower(),
                            "timestamp": self._format_timestamp(log_line.get("asctime")),
                        }
                    )
            except Exception:
                pass
        return formatted_logs[:LOG_EXPORT_BATCH_SIZE]

    def _export_logs(self, api_key: str, agent_instance_id: str, formatted_logs: List[Dict]) -> bool:
        is_export_success = False
        if formatted_logs:
            try:
                response = requests.post(
                    urljoin(GALADRIEL_API_BASE_URL, f"v1/agents/logs/{agent_instance_id}"),
                    timeout=60,
                    headers={
                        "Content-Type": "application/json",
                        "Authorization": f"Bearer {api_key}",
                    },
                    json={"logs": formatted_logs},
                )
                self.logger.debug(f"Log export request status: {response.status_code}")
                is_export_success = response.ok
            except Exception:
                self.logger.error("Failed to export logs", exc_info=True)
        return is_export_success

    def _format_timestamp(self, asctime: Optional[str]) -> int:
        if not asctime:
            return 0
        try:
            dt_obj = datetime.strptime(asctime, "%Y-%m-%d %H:%M:%S,%f").replace(tzinfo=timezone.utc)
            return int(dt_obj.timestamp())
        except Exception:
            return 0


================================================
File: /galadriel/domain/publish_proof.py
================================================
import json
import os
from typing import Optional

import requests

from galadriel.entities import Message
from galadriel.logging_utils import get_agent_logger

logger = get_agent_logger()


def execute(request: Message, response: Message, hashed_data: str) -> bool:
    # TODO: url = "https://api.galadriel.com/v1/verified/chat/log"
    url = "http://localhost:5000/v1/verified/chat/log"
    headers = {
        "accept": "application/json",
        "Content-Type": "application/json",
        "Authorization": _get_authorization(),
    }
    data = {
        "attestation": "TODO:",  # TODO
        "hash": hashed_data,
        "public_key": "TODO:",  # TODO
        "request": request.model_dump(),
        "response": response.model_dump(),
        "signature": "TODO:",  # TODO
    }
    try:
        result = requests.post(url, headers=headers, data=json.dumps(data), timeout=30)
        if result.status_code == 200:
            return True
    except Exception:
        pass
    return False


def _get_authorization() -> Optional[str]:
    api_key = os.getenv("GALADRIEL_API_KEY")
    if api_key:
        return "Bearer " + api_key
    logger.debug("GALADRIEL_API_KEY env variable missing skipping proof publishing.")
    return None


================================================
File: /galadriel/domain/prompts/format_prompt.py
================================================
from typing import Dict
import json
import random


def execute(prompt_template: str, prompt_state: Dict) -> str:
    prompt = prompt_template
    for k, v in prompt_state.items():
        prompt = prompt.replace("{{" + k + "}}", str(v))
    return prompt


def load_agent_template(template: str, json_path: str) -> str:
    """
    Load agent personality from JSON and update template with random values.

    Args:
        template (str): The template string containing placeholders
        json_path (str): Path to the JSON file containing agent personality data

    Returns:
        str: Updated template with randomly selected values
    """
    try:
        with open(json_path, "r", encoding="utf-8") as f:
            data = json.load(f)

        agent_values = {
            "knowledge": random.choice(data.get("knowledge", [])),
            "agent_name": data.get("name"),
            "system": data.get("system"),
            "bio": random.choice(data.get("bio", [])),
            "lore": random.choice(data.get("lore", [])),
            "topics": random.choice(data.get("topics", [])),
        }

        updated_template = execute(template, agent_values)

        return updated_template

    except FileNotFoundError:
        raise FileNotFoundError(f"Agent personality file not found: {json_path}")
    except json.JSONDecodeError:
        raise ValueError(f"Invalid JSON file: {json_path}")
    except KeyError as e:
        raise KeyError(f"Missing required key in JSON file: {e}")


================================================
File: /galadriel/domain/generate_proof.py
================================================
import hashlib
import json

from galadriel.entities import Message


def execute(request: Message, response: Message) -> str:
    # print("request:", request)
    # print("response:", response)
    return _hash_data(request, response)


def _hash_data(request: Message, response: Message) -> str:
    combined_str = f"{_dump(request)}{_dump(response)}"
    return hashlib.sha256(combined_str.encode("utf-8")).digest().hex()


def _dump(message: Message) -> str:
    if message:
        return json.dumps(message.model_dump(), sort_keys=True)
    return ""


================================================
File: /galadriel/domain/validate_solana_payment.py
================================================
from dataclasses import dataclass
from typing import List
from typing import Optional
from typing import Set

from solana.rpc.api import Client
from solders.pubkey import Pubkey  # pylint: disable=E0401
from solders.signature import Signature  # pylint: disable=E0401

from galadriel.entities import Message
from galadriel.entities import Pricing
from galadriel.errors import PaymentValidationError


@dataclass
class TaskAndPaymentSignature:
    task: str
    signature: str


@dataclass
class TaskAndPaymentSignatureResponse(TaskAndPaymentSignature):
    amount_transferred_lamport: int


def execute(pricing: Pricing, existing_payments: Set[str], request: Message) -> TaskAndPaymentSignatureResponse:
    """Validate the payment for the request.
    Args:
        pricing: Pricing configuration, containing the wallet address and payment amount required
        existing_payments: Already validated payments to avoid duplications
        request: The message containing the transaction signature
    Returns:
        The task to be executed
    Raises:
        PaymentValidationError: If the payment validation fails
    """
    task_and_payment = _extract_transaction_signature(request.content)
    if not task_and_payment:
        raise PaymentValidationError(
            "No transaction signature found in the message. Please include your payment transaction signature."
        )
    if task_and_payment.signature in existing_payments:
        raise PaymentValidationError(
            f"Transaction {task_and_payment.signature} has already been used. Please submit a new payment."
        )
    sol_transferred_lamport = _get_sol_amount_transferred(pricing, task_and_payment.signature)
    if sol_transferred_lamport < pricing.cost * 10**9:
        raise PaymentValidationError(
            f"Payment validation failed for transaction {task_and_payment.signature}. "
            f"Please ensure you've sent {pricing.cost} SOL to {pricing.wallet_address}"
        )
    existing_payments.add(task_and_payment.signature)
    return TaskAndPaymentSignatureResponse(
        task=task_and_payment.task,
        signature=task_and_payment.signature,
        amount_transferred_lamport=sol_transferred_lamport,
    )


def _get_sol_amount_transferred(pricing: Pricing, tx_signature: str) -> int:
    http_client = Client("https://api.mainnet-beta.solana.com")
    tx_sig = Signature.from_string(tx_signature)
    tx_info = http_client.get_transaction(tx_sig=tx_sig, max_supported_transaction_version=10)
    if not tx_info.value:
        return False
    transaction = tx_info.value.transaction.transaction  # The actual transaction
    account_keys = transaction.message.account_keys  # type: ignore
    index = _get_key_index(account_keys, pricing.wallet_address)  # type: ignore
    if index < 0:
        return False

    meta = tx_info.value.transaction.meta
    if meta.err is not None:  # type: ignore
        return False

    pre_balance = meta.pre_balances[index]  # type: ignore
    post_balance = meta.post_balances[index]  # type: ignore
    amount_sent = post_balance - pre_balance
    return amount_sent


def _get_key_index(account_keys: List[Pubkey], wallet_address: str) -> int:
    """
    Returns the index of the wallet address
    :param account_keys:
    :param wallet_address:
    :return: non-zero number if present, -1 otherwise
    """
    wallet_key = Pubkey.from_string(wallet_address)
    for i, key in enumerate(account_keys):
        if wallet_key == key:
            return i
    return -1


def _extract_transaction_signature(message: str) -> Optional[TaskAndPaymentSignature]:
    """
    Given a string parses it to the task and the payment
    For example: "How long should I hold my ETH portfolio before selling?
    https://solscan.io/tx/5aqB4BGzQyFybjvKBjdcP8KAstZo81ooUZnf64vSbLLWbUqNSGgXWaGHNteiK2EJrjTmDKdLYHamJpdQBFevWuvy"

    :param message: string
    :return: TaskAndPaymentSignature if valid, none otherwise
    """
    if not message:
        return None

    if "https://solscan.io/tx/" in message:
        task, payment = message.split("https://solscan.io/tx/")
        task = task.strip()
        payment_signature = payment.replace("https://solscan.io/tx/", "").strip()
        return TaskAndPaymentSignature(
            task=task,
            signature=payment_signature,
        )

    signature = _find_signature(message)
    if signature:
        task = message.replace(signature, "").strip()
        return TaskAndPaymentSignature(task=task, signature=signature)
    return None


def _find_signature(message: str) -> Optional[str]:
    for word in message.split():
        try:
            signature = Signature.from_string(word.strip())
            return str(signature)
        except Exception:
            pass
    return None


================================================
File: /galadriel/logging_utils.py
================================================
import logging
import os
from logging import DEBUG
from logging import INFO
from typing import Optional

from pythonjsonlogger import jsonlogger

from galadriel.domain.logs_exporter import LogsExportHandler

GALADRIEL_NODE_LOGGER = "galadriel"

LOG_FILE_PATH = "logs/logs.log"
LOGGING_MESSAGE_FORMAT = "%(asctime)s %(name)-12s %(levelname)s %(message)s"

logger: Optional[logging.Logger] = None


def init_logging(debug: bool):
    global logger  # pylint:disable=W0603
    if logger:
        return
    log_level = DEBUG if debug else INFO
    file_handler = _get_file_logger()
    console_handler = _get_console_logger()
    logger = logging.getLogger()
    logs_exports_handler = LogsExportHandler(logger)
    logger.setLevel(log_level)
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    logger.addHandler(logs_exports_handler)
    apply_default_formatter(file_handler)
    apply_default_formatter(console_handler)
    apply_default_formatter(logs_exports_handler)
    logger.propagate = False

    logs_exports_handler.run()


def _get_file_logger() -> logging.FileHandler:
    os.makedirs(os.path.dirname(LOG_FILE_PATH), exist_ok=True)
    file_handler = logging.FileHandler(LOG_FILE_PATH)
    file_handler.setLevel(logging.DEBUG)
    return file_handler


def _get_console_logger() -> logging.StreamHandler:
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.DEBUG)
    return console_handler


def apply_default_formatter(handler: logging.Handler):
    formatter = jsonlogger.JsonFormatter(LOGGING_MESSAGE_FORMAT)
    handler.setFormatter(formatter)


def get_agent_logger():
    return logging.getLogger()


================================================
File: /README.md
================================================
# Galadriel

Galadriel is a Python framework for building autonomous, economically useful AI Agents.

## Quickstart
Note: you should setup local env for this. In terminal
```shell
python3 -m venv venv
source venv/bin/activate
```

And then, install `galadriel` package.
```shell
pip install galadriel
```

Now, create a new python file and copy the code below to create sample agent.
It uses `TestClient` which sends 2 messages sequentially to the agent and prints the result of agent execution.

```python
import asyncio
from galadriel import AgentRuntime, CodeAgent
from galadriel.clients import SimpleMessageClient
from galadriel.core_agent import LiteLLMModel, DuckDuckGoSearchTool

model = LiteLLMModel(model_id="gpt-4o", api_key="<ADD YOUR OPENAI KEY HERE>")

agent = CodeAgent(
    model=model,
    tools=[DuckDuckGoSearchTool()]
)

client = SimpleMessageClient("Explain the concept of blockchain")

runtime = AgentRuntime(
    agent=agent,
    inputs=[client],
    outputs=[client],
)
asyncio.run(runtime.run())
```

## Components

### Clients  
Clients serve as the bridge between agents and external data sources, handling both input and output operations. An input client (`AgentInput`) supplies messages to the agent, while an output client (`AgentOutput`) delivers the agentâ€™s responses to their intended destination. This modular design allows seamless integration with a variety of sources, from scheduled jobs (like cron tasks) to interactive applications (such as Discord bots).

### Tools  
Tools extend an agentâ€™s capabilities by providing predefined functions that enable interaction with external APIs, data sources, and systems. These tools empower agents to perform tasks such as fetching real-time weather updates or submitting blockchain transactions. Each tool defines its name, purpose, input requirements, and output format, ensuring structured and meaningful interactions. Galadriel supports any tool from HuggingFace, Composio and Langchain out-of-the-box.

### Agents  
Agents are the core intelligence behind the system, capable of reasoning, processing inputs, and generating informed responses. Our framework supports ToolCallingAgent and CodeAgent, which build upon Hugging Faceâ€™s [Smolagents](https://github.com/huggingface/smolagents) while introducing enhancements for improved integration with the runtime. Agents leverage ReAct-based reasoning and can access a wide variety of LLMs via [LiteLLM](https://www.litellm.ai/). Additionally, they can be configured with custom personalities and interact with powerful tools to enhance their decision-making capabilities.

### Runtime  
The Agent Runtime ensures continuous and autonomous agent execution. It manages the lifecycle of agent interactions, efficiently processing incoming requests while maintaining agent state. The runtime follows a structured execution loop:

1. **Receive a Message** â€“ An input client sends a message to the runtime.
2. **Process the Message** â€“ The agent receives and handles the request.
3. **Send the Response** â€“ The agent's output is forwarded to the appropriate client.
4. **Repeat** â€“ The runtime continuously handles incoming messages in a loop.

This architecture enables real-time, scalable, and efficient agent operations across diverse environments.


================================================
File: /DEV_README.md
================================================
# Galadriel Agent development setup 

### Requirement

- Python >=3.10
- Git

### Setup for local development

```shell
pip install -e ".[dev]"
```

## Run an agent example agent
```shell
cd examples/{example}
pip install -r requirements.txt  # if relevant for the example
cp template.env .env  # If relevant for the example
python agent.py
```

## Linting, code formatting, type-checking â—â—â—
```shell
source toolbox.sh
lint
format
type-check
```

## Testing
Ensure that dev dependencies are installed
```shell
source toolbox.sh
unit-test
```


## Running from a package locally

In a separate venv
```shell
pip install --no-cache-dir -e ../galadriel-agent
galadriel --help
```

================================================
File: /examples/twitter/tweet_from_tool.py
================================================
import asyncio
import os
from pathlib import Path

from dotenv import load_dotenv

from galadriel import CodeAgent
from galadriel import AgentRuntime
from galadriel.clients import Cron
from galadriel.core_agent import LiteLLMModel
from galadriel.tools.twitter import TwitterPostTool

load_dotenv(dotenv_path=Path(".") / ".env", override=True)
llm_model = LiteLLMModel(model_id="gpt-4o", api_key=os.getenv("OPENAI_API_KEY"))

POST_INTERVAL_SECONDS = 5

AGENT_PROMPT = """
You are a humorous Twitter user. 
Every time you are called:
1. Generate a short tweet (1-2 sentences). About any topic.
2. Post the tweet.
"""

agent = CodeAgent(
    prompt_template=AGENT_PROMPT,
    model=llm_model,
    tools=[TwitterPostTool()],
)

runtime = AgentRuntime(
    agent=agent,
    inputs=[Cron(POST_INTERVAL_SECONDS)],
    outputs=[],  # No output, posting happens inside Agent
)

asyncio.run(runtime.run())


================================================
File: /examples/twitter/README.md
================================================
# Twitter "agent" example

This is a Twitter "agent" that posts on twitter every 3 hours.
It has a cron job that triggers every 3 hours and generates a Twitter post
that is then posted on Twitter through its official API.

## Features

- ðŸ¤– Works automatically with no user input
- ðŸŒ¤ï¸ Posts tweets using a Twitter Client

## Framework Components Used

This example demonstrates several key features of the Galadriel framework:

- `Cron`: Triggers agent actions at a configured interval
- `Agent`: Implements the base Agent interface for a custom "agent" implementation
- `LiteLLMModel`: Integration with language models via LiteLLM
- Custom tools:
    - Composio Weather API (converted using `convert_action`)
    - Time tool
- `TwitterPostClient`: A client for posting Tweets on Twitter

## Setup and Running

1. Setup local env and install `galadriel`.

```bash
```shell
pip install -r requirements.txt
python3 -m venv venv
source venv/bin/activate
pip install galadriel
```

2. Rename `template.env` to `.env` and add your OpenAI API key
   along with credentials for Twitter.

```bash
OPENAI_API_KEY=

# Under "Consumer Keys"
TWITTER_CONSUMER_API_KEY=
TWITTER_CONSUMER_API_SECRET=
# Under "Authentication Tokens -> "Access Token and Secret" (requires Write permission)
TWITTER_ACCESS_TOKEN=
TWITTER_ACCESS_TOKEN_SECRET=
```

Check out https://developer.x.com/, for these values.
User authentication needs to be set up with write access.


You can also include something like

```bash
DRY_RUN=true
```

in your `.env` to skip the actual Twitter posting part, just to see
what the Agent would have posted. This can be useful for testing and
modifying the prompt.

4. Run the agent:

```bash
python twitter_agent.py
```

================================================
File: /examples/twitter/tweet_from_output.py
================================================
import asyncio
import os
from pathlib import Path

from dotenv import load_dotenv

from galadriel import CodeAgent
from galadriel import AgentRuntime
from galadriel.clients import Cron
from galadriel.clients.twitter_post_client import TwitterPostClient
from galadriel.core_agent import LiteLLMModel

load_dotenv(dotenv_path=Path(".") / ".env", override=True)
llm_model = LiteLLMModel(model_id="gpt-4o", api_key=os.getenv("OPENAI_API_KEY"))

POST_INTERVAL_SECONDS = 5

AGENT_PROMPT = """
You are a humorous Twitter user. 
Generate a short tweet (1-2 sentences). About any topic.
"""

agent = CodeAgent(
    prompt_template=AGENT_PROMPT,
    model=llm_model,
    tools=[],
)

runtime = AgentRuntime(
    agent=agent,
    inputs=[Cron(POST_INTERVAL_SECONDS)],
    outputs=[TwitterPostClient()],
)

asyncio.run(runtime.run())


================================================
File: /examples/payments/README.md
================================================
# Payments

## Description

This example demonstrates a research agent which receives **SOL payments** from users before executing tasks. The agent is designed to analyze investment-related queries and retrieve relevant data from Web3 tools. It uses:

- gpt-4o model from OpenAI for language processing.
- [CodeAgent](https://github.com/galadriel-ai/galadriel/blob/main/galadriel/agent.py) which performs a series of steps until it reaches the final result.
- AgentRuntime to connect various clients to the agent and execute the agent logic.
- Clients:
  - TwitterMentionClient (commented out by default) for processing mentions on Twitter.
  - SimpleMessageClient as a local test client with predefined messages.
- Web3 Tools:
  - get_coin_price from CoinGecko to fetch real-time cryptocurrency prices.
  - get_token_profile from DexScreener to retrieve token profiles.
- Pricing Mechanism, requiring users to pay in **Solana (SOL)** to the agent's wallet before the agent executes the task.

### Payment and Transaction Requirements

The client must provide a task with one of the following:

- A link to a Solana transaction (e.g., from Solscan)
- A transaction signature on the Solana blockchain

## Running the agent

1. Setup local env and install `galadriel`.

```shell
python3 -m venv venv
source venv/bin/activate
pip install galadriel
```

2. Create an agent wallet where the agent will receive SOL payments.

3. Rename `template.env` to `.env` and add your agent wallet address and OpenAI API key along with credentials for Twitter if needed.

4. Configure the agent wallet for receiving SOL payments.

5. Run the agent:

   ```sh
   python agent.py
   ```

By default, the script includes a test client (`SimpleMessageClient`). If you want to enable Twitter integration, uncomment the corresponding section in `agent.py` and provide the required API credentials in the `.env` file.


================================================
File: /examples/payments/agent.py
================================================
import asyncio
import os
from pathlib import Path

from dotenv import load_dotenv

from galadriel import AgentRuntime, CodeAgent
from galadriel.clients import SimpleMessageClient
from galadriel.core_agent import LiteLLMModel
from galadriel.entities import Pricing
from galadriel.tools.web3 import dexscreener, coingecko

load_dotenv(dotenv_path=Path(".") / ".env", override=True)

model = LiteLLMModel(
    model_id="openai/gpt-4o",
    api_key=os.getenv("OPENAI_API_KEY"),
)

# Set up a researcher who will perform Web3 related tasks
researcher = CodeAgent(
    tools=[
        coingecko.get_coin_price,
        dexscreener.get_token_profile,
    ],
    model=model,
    add_base_tools=True,
)

# Configure agent's pricing information
agent_pricing = Pricing(
    wallet_address="5RYHzQuknP2viQjYzP27wXVWKeaxonZgMBPQA86GV92t",  # Agent's wallet address
    cost=0.001,  # Price per task in SOL
)

# The client will pass a research task to the agent with either
# - a link to the transaction on Solscan
# - a signature of transaction of Solana
# Example transaction passed to SimpleMessageClient below:
# https://explorer.solana.com/tx/5aqB4BGzQyFybjvKBjdcP8KAstZo81ooUZnf64vSbLLWbUqNSGgXWaGHNteiK2EJrjTmDKdLYHamJpdQBFevWuvy
simple_client = SimpleMessageClient(
    "Is Bitcoin good investment now with high prices? 5aqB4BGzQyFybjvKBjdcP8KAstZo81ooUZnf64vSbLLWbUqNSGgXWaGHNteiK2EJrjTmDKdLYHamJpdQBFevWuvy",
)

# Alternatively, Twitter (or Discord, Telegram) client which can be passed to inputs and outputs in order to get tasks from social channels
# twitter_client = TwitterMentionClient(
#     TwitterCredentials(
#         consumer_api_key=os.getenv("TWITTER_CONSUMER_API_KEY"),
#         consumer_api_secret=os.getenv("TWITTER_CONSUMER_API_SECRET"),
#         access_token=os.getenv("TWITTER_ACCESS_TOKEN"),
#         access_token_secret=os.getenv("TWITTER_ACCESS_TOKEN_SECRET"),
#     ),
#     user_id=os.getenv("TWITTER_USER_ID"),
# )

# Combine all elements into runtime
runtime = AgentRuntime(
    inputs=[simple_client],  # Runtime inputs, pass twitter_client if you use it
    outputs=[simple_client],  # Runtime outputs, pass twitter_client if you use it
    agent=researcher,
    pricing=agent_pricing,
)

# Run the runtime with agent
asyncio.run(runtime.run())


================================================
File: /examples/basic-web3/README.md
================================================
# Web3 Example

## Description

This example demonstrates an agent which checks market data for a specific token.
It uses:

- `gpt-4o` model from OpenAI
- [CodeAgent](https://github.com/galadriel-ai/galadriel/blob/main/galadriel/agent.py) which performs a series of steps until it reaches the final result
- `SimpleMessageClient` which simulates user input in the form of market-related question
- `AgentRuntime` which connects the client to agent and runs the agent execution
- `dexscreener.fetch_market_data` Web3 tool which fetches market data for top tokens

Returns the response similar to this one:

```
Question: What are top tokens on the market today?
Answer: The top tokens by 24-hour volume are: 'Trump's Tax Company', 'dogwifouthat', 'THE DARK KNIGHT', and 'BRITISH DOG'

Question: Should I buy ETH?
Answer: Consider buying ETH if you are comfortable with its recent volatility and believe in its long-term potential, but ensure your decision aligns with your financial goals and risk tolerance.
```

## Running the agent

1. Setup local env and install `galadriel`.

```shell
python3 -m venv venv
source venv/bin/activate
pip install galadriel
```

2. Rename `template.env` to `.env` and add your OpenAI API Key.
3. Run the agent.

```shell
python agent.py
```


================================================
File: /examples/basic-web3/agent.py
================================================
import asyncio
import os
from pathlib import Path

from dotenv import load_dotenv

from galadriel import AgentRuntime, CodeAgent
from galadriel.clients import SimpleMessageClient
from galadriel.core_agent import LiteLLMModel, DuckDuckGoSearchTool
from galadriel.tools.web3 import dexscreener

load_dotenv(dotenv_path=Path(".") / ".env", override=True)
model = LiteLLMModel(model_id="gpt-4o", api_key=os.getenv("OPENAI_API_KEY"))

# Add agent with GPT-4o model and access to web search and market data
agent = CodeAgent(
    model=model,
    tools=[DuckDuckGoSearchTool(), dexscreener.fetch_market_data],
    additional_authorized_imports=["json"],
)

# Add basic client which sends two messages to the agent and prints agent's result
client = SimpleMessageClient("What are top tokens on the market today?", "Should I buy ETH?")

# Set up the runtime
runtime = AgentRuntime(
    agent=agent,
    inputs=[client],
    outputs=[client],
)

# Run the agent
asyncio.run(runtime.run())


================================================
File: /examples/discord/character_agent.py
================================================
import json
from pathlib import Path

from rich.text import Text

from galadriel import ToolCallingAgent
from galadriel.core_agent import LogLevel
from galadriel.domain.prompts.format_prompt import load_agent_template
from galadriel.entities import AgentMessage
from galadriel.entities import Message

DISCORD_SYSTEM_PROMPT = """
{{system}}

# Areas of Expertise
{{knowledge}}

# About {{agent_name}}:
{{bio}}
{{lore}}
{{topics}}

# Task: You received a new message on discord from {{user_name}}. You must reply in the voice and style of {{agent_name}}, here's the message:
{{message}}

Be very brief, and concise, add a statement in your voice.
Maintain a natural conversation on discord, don't add signatures at the end of your messages.
Don't overuse emojis.
Please remember the chat history and use it to answer the question.
"""


class CharacterAgent(ToolCallingAgent):
    def __init__(self, character_json_path: str, **kwargs):
        super().__init__(**kwargs)
        try:
            self.character_json_path = character_json_path
            # validate content of character_json_path
            _ = load_agent_template(DISCORD_SYSTEM_PROMPT, Path(self.character_json_path))
        except Exception as e:
            self.logger.log(Text(f"Error validating character file: {e}"), level=LogLevel.ERROR)
            raise e

    async def execute(self, message: Message) -> Message:
        try:
            # Load the agent template on every execution to ensure randomness
            character_prompt = load_agent_template(DISCORD_SYSTEM_PROMPT, Path(self.character_json_path))
            task_message = character_prompt.replace("{{message}}", message.content).replace(
                "{{user_name}}", message.additional_kwargs["author"]
            )
            # Use parent's run method to process the message content
            response = super().run(
                task=task_message,
                stream=False,
                reset=False,  # retain memory
            )

            # Extract message text if response is in JSON format
            response_text = str(response)
            try:
                response_json = json.loads(response_text)
                if isinstance(response_json, dict) and "answer" in response_json:
                    response_text = response_json["answer"]
            except json.JSONDecodeError:
                pass  # Not JSON format, use original response

            return AgentMessage(
                content=response_text,
                conversation_id=message.conversation_id,
            )
        except Exception as e:
            self.logger.log(Text(f"Error processing message: {e}"), level=LogLevel.ERROR)
            return None


================================================
File: /examples/discord/tools.py
================================================
from galadriel.core_agent import tool
from datetime import datetime


@tool
def get_time(location: str) -> str:
    """
    Get current time in the given location.
    Args:
        location: the location
    """
    return f"The time in {location} is {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"


================================================
File: /examples/discord/agent.json
================================================
{
  "name": "Elon Musk",
  "settings": {
    "model": "gpt-4",
    "debug": true
  },
  "system": "You are roleplaying as Elon Musk, CEO of Tesla, SpaceX, and X (formerly Twitter). You are known for your ambitious goals in sustainable energy, space exploration, and technological innovation. You have a unique communication style mixing technical depth with memes and humor.",
  "bio": [
    "Entrepreneur focused on accelerating humanity's transition to sustainable energy and making life multi-planetary",
    "Believes in taking bold risks to advance technology and human civilization",
    "Known for controversial statements and unorthodox leadership style"
  ],
  "lore": [
    "Sold PayPal to focus on rockets and electric cars when everyone said it was impossible",
    "Lives in a $50k house despite being one of the world's wealthiest people",
    "Named his child X Ã† A-12",
    "Hosted SNL and revealed he has Asperger's syndrome",
    "Bought Twitter for $44B and renamed it to X"
  ],
  "adjectives": [
    "ambitious",
    "controversial",
    "innovative",
    "workaholic",
    "eccentric",
    "technical",
    "visionary"
  ],
  "topics": [
    "sustainable energy",
    "space exploration",
    "artificial intelligence",
    "electric vehicles",
    "neural technology",
    "social media",
    "cryptocurrency"
  ],
  "style": {
    "all": [
      "mix technical details with humor",
      "use occasional memes",
      "be direct and sometimes controversial",
      "show passion for humanity's future"
    ],
    "chat": [
      "give detailed technical responses",
      "challenge conventional thinking",
      "use analogies to explain complex concepts"
    ],
    "post": [
      "keep it short and punchy",
      "use dry humor",
      "occasionally post memes",
      "make bold statements about the future"
    ]
  },
  "goals_template": [
    "Make life multi-planetary",
    "Accelerate sustainable energy adoption",
    "Develop safe artificial general intelligence",
    "Revolutionize human-computer interfaces",
    "Transform transportation with electric vehicles and tunnels"
  ],
  "facts_template": [
    "Founded SpaceX in 2002",
    "Joined Tesla as chairman in 2004",
    "Became Tesla CEO in 2008",
    "Launched first successful private orbital rocket in 2008",
    "Successfully landed and reused orbital rockets",
    "Created Neuralink to develop brain-computer interfaces",
    "Acquired Twitter in 2022 for $44B"
  ],
  "knowledge": [
    "Rocket engineering and orbital mechanics",
    "Electric vehicle technology and manufacturing",
    "Renewable energy systems and battery technology",
    "Artificial intelligence and its potential risks",
    "Software engineering and internet technology",
    "Physics and engineering principles",
    "Business strategy and scaling operations"
  ],
  "twitter_profile": {
    "username": "elonmusk",
    "screen_name": "Elon Musk",
    "bio": "Mars & Cars, Chips & Dips",
    "nicknames": [
      "Technoking",
      "Space Karen",
      "Dogefather",
      "Chief Twit"
    ]
  },
  "search_queries": {
    "tech_news": [
      "Tesla news",
      "SpaceX launches",
      "AI developments",
      "renewable energy breakthroughs"
    ]
  }
}


================================================
File: /examples/discord/README.md
================================================
# Discord Elon Musk Agent Example

A Discord bot that simulates Elon Musk's personality, capable of interacting with users in a Discord server. The bot can provide weather information and tell the current time while maintaining Elon's characteristic communication style.

## Features

- ðŸ¤– Responds to messages in Discord channels with Elon Musk's personality
- ðŸŒ¤ï¸ Can check weather conditions using the Composio Weather API
- â° Provides current time information
- ðŸ”„ Maintains context and can engage in multi-turn conversations

## Framework Components Used

This example demonstrates several key features of the Galadriel framework:

- `DiscordClient`: Handles Discord message input/output
- `ToolCallingAgent`: Base agent class for handling tool-based interactions
- `LiteLLMModel`: Integration with language models via LiteLLM
- Custom tools:
  - Composio Weather API (converted using `convert_action`)
  - Time tool

## Setup and Running

1. Setup local env and install `galadriel`.

```shell
python3 -m venv venv
source venv/bin/activate
pip install galadriel
```

2. Create a `.env` file with the following variables:

```bash
DISCORD_TOKEN=
DISCORD_APP_ID=
DISCORD_GUILD_ID=
DISCORD_KEY=
OPENAI_API_KEY=
COMPOSIO_API_KEY=
```

3. Make sure you have the `agent.json` file in the same directory, which defines Elon Musk's personality traits.

4. Run the agent:

```bash
python discord_agent.py
```

## Discord Bot Setup

Follow the instructions in the [Discord API documentation](https://discordpy.readthedocs.io/en/stable/discord.html) to create a new application and bot.
Make sure your bot has sufficient "Bot Permissions" - especially "Send Messages" and "Read Message History"


================================================
File: /examples/discord/agent.py
================================================
from galadriel.core_agent import LiteLLMModel
from dotenv import load_dotenv
from pathlib import Path

from character_agent import CharacterAgent
from galadriel.tools.composio_converter import convert_action
from tools import get_time
from galadriel import AgentRuntime
from galadriel.clients import DiscordClient
import os
import asyncio
from galadriel.logging_utils import get_agent_logger


load_dotenv(dotenv_path=Path(".") / ".env", override=True)
model = LiteLLMModel(model_id="gpt-4o", api_key=os.getenv("OPENAI_API_KEY"))


logger = get_agent_logger()

# Setup Discord client which
# - pushes users' messages to the agent
# - sends agent's responses back to the users
discord_client = DiscordClient(guild_id=os.getenv("DISCORD_GUILD_ID"))

# Setup Composio weather tool
composio_weather_tool = convert_action(os.getenv("COMPOSIO_API_KEY"), "WEATHERMAP_WEATHER")

# Add agent with GPT-4o model and tools helpful to answer Discord users' questions
elon_musk_agent = CharacterAgent(
    character_json_path="agent.json",
    tools=[get_time],
    model=model,
)

# Set up the runtime
runtime = AgentRuntime(
    inputs=[discord_client],
    outputs=[discord_client],
    agent=elon_musk_agent,
)

# Run the agent
asyncio.run(runtime.run())


================================================
File: /examples/deterministic/README.md
================================================
# Deterministic Agent Example

This is an example of deterministic Twitter "agent" that posts on twitter every 3 hours.
It has a cron job that triggers every 3 hours and generates a Twitter post
that is then posted on Twitter through its official API.

## Why deterministic?

The _agency_ of agents exists on a spectrum. The more agentic an agent is, the more its behavior is influenced by the LLM. 
However, there is a tradeoffâ€”LLM execution is probabilistic, meaning it may not always produce the same behavior. 
In some cases, a developer may prefer a more deterministic approach to ensure consistency.

In this example, the developer chose to make the Twitter agent follow a fixed process in each iteration of the loop:
1. Retrieve the content of the tweet from the LLM.
2. Post the tweet.

Allowing the LLM to make probabilistic decisions in this scenario would only increase costs and reduce the reliability of the desired flow.
At the same time, the developer still wanted to leverage key functionalities of the framework, such as tooling, orchestration (`Cron`), and more.

## Features

- ðŸ¤– Works automatically with no user input
- ðŸŒ¤ï¸ Posts tweets using a Twitter Client

## Framework Components Used

This example demonstrates several key features of the Galadriel framework:

- `Cron`: Triggers agent actions at a configured interval
- `Agent`: Implements the base Agent interface for a custom "agent" implementation
- `LiteLLMModel`: Integration with language models via LiteLLM
- Custom tools:
    - Composio Weather API (converted using `convert_action`)
    - Time tool
- `TwitterPostClient`: A client for posting Tweets on Twitter

## Setup and Running

1. Setup local env and install `galadriel`.

```bash
```shell
pip install -r requirements.txt
python3 -m venv venv
source venv/bin/activate
pip install galadriel
```

2. Rename `template.env` to `.env` and add your OpenAI API key
   along with credentials for Twitter.

```bash
OPENAI_API_KEY=

# Under "Consumer Keys"
TWITTER_CONSUMER_API_KEY=
TWITTER_CONSUMER_API_SECRET=
# Under "Authentication Tokens -> "Access Token and Secret" (requires Write permission)
TWITTER_ACCESS_TOKEN=
TWITTER_ACCESS_TOKEN_SECRET=
```

Check out https://developer.x.com/, for these values.
User authentication needs to be set up with write access.


You can also include something like

```bash
DRY_RUN=true
```

in your `.env` to skip the actual Twitter posting part, just to see
what the Agent would have posted. This can be useful for testing and
modifying the prompt.

4. Run the agent:

```bash
python twitter_agent.py
```


================================================
File: /examples/deterministic/agent.py
================================================
import asyncio
import os
from pathlib import Path

from dotenv import load_dotenv

from galadriel import Agent
from galadriel import AgentRuntime
from galadriel.clients import Cron
from galadriel.clients.twitter_post_client import TwitterPostClient
from galadriel.core_agent import LiteLLMModel
from galadriel.entities import Message

load_dotenv(dotenv_path=Path(".") / ".env", override=True)
llm_model = LiteLLMModel(model_id="gpt-4o", api_key=os.getenv("OPENAI_API_KEY"))

POST_INTERVAL_SECONDS = 3 * 60 * 60  # 3 hours
AGENT_PROMPT = """
You are a humorous Twitter user. Generate a short tweet (1-2 sentences). About any topic.
"""


class TwitterAgent(Agent):
    prompt: str
    model: LiteLLMModel

    def __init__(
        self,
        prompt: str,
        model: LiteLLMModel,
    ):
        self.prompt = prompt
        self.model = model

    async def execute(self, request: Message) -> Message:
        response = self.model(
            [
                {
                    "role": "system",
                    "content": self.prompt,
                }
            ]
        )
        return Message(content=response.content)


agent = TwitterAgent(
    prompt=AGENT_PROMPT,
    model=llm_model,
)

runtime = AgentRuntime(
    agent=agent,
    inputs=[Cron(POST_INTERVAL_SECONDS)],
    outputs=[TwitterPostClient()],
)

asyncio.run(runtime.run())


================================================
File: /examples/basic/README.md
================================================
# Basic example

## Description

This example demonstrates an agent which receives and processes a sequence of messages. It uses:

- `gpt-4o` model from OpenAI
- [CodeAgent](https://github.com/galadriel-ai/galadriel/blob/main/galadriel/agent.py) which performs a series of steps until it reaches the final result
- `SimpleMessageClient` which implements
  - `AgentInput` to infinitely send predefined messages to the agent
  - `AgentOutput` to receive results from the agent and print them
- `AgentRuntime` which connects the client to agent and runs the agent execution
- `DuckDuckGoSearchTool` tool used to browse the web

The agent produces sequentially the answers to given questions.

## Running the agent

1. Setup local env and install `galadriel`.

```shell
python3 -m venv venv
source venv/bin/activate
pip install galadriel
```

2. Rename `template.env` to `.env` and add your OpenAI API Key.
3. Run the agent.

```shell
python agent.py
```


================================================
File: /examples/basic/agent.py
================================================
import asyncio
import os
from pathlib import Path

from dotenv import load_dotenv

from galadriel import AgentRuntime, CodeAgent
from galadriel.clients import SimpleMessageClient
from galadriel.core_agent import LiteLLMModel, DuckDuckGoSearchTool

load_dotenv(dotenv_path=Path(".") / ".env", override=True)
model = LiteLLMModel(model_id="gpt-4o", api_key=os.getenv("OPENAI_API_KEY"))

# Add agent with GPT-4o model and DuckDuckGo search tool
agent = CodeAgent(
    model=model,
    tools=[DuckDuckGoSearchTool()],
)

# Add basic client which sends two messages to the agent and prints agent's result
client = SimpleMessageClient("What is the capital of Estonia?", "What's the price of Solana today?")

# Set up the runtime
runtime = AgentRuntime(
    agent=agent,
    inputs=[client],
    outputs=[client],
)

# Run the agent
asyncio.run(runtime.run())


================================================
File: /examples/telegram/character_agent.py
================================================
import json
from pathlib import Path

from rich.text import Text

from galadriel import ToolCallingAgent
from galadriel.core_agent import LogLevel
from galadriel.domain.prompts.format_prompt import load_agent_template
from galadriel.entities import AgentMessage
from galadriel.entities import Message

TELEGRAM_SYSTEM_PROMPT = """
{{system}}

# Areas of Expertise
{{knowledge}}

# About {{agent_name}}:
{{bio}}
{{lore}}
{{topics}}

# Task: You received a new message on telegram from {{user_name}}. You must reply in the voice and style of {{agent_name}}, here's the message:
{{message}}

Be very brief, and concise, add a statement in your voice.
Maintain a natural conversation on telegram, don't add signatures at the end of your messages.
Don't overuse emojis.
Please remember the chat history and use it to answer the question.
"""


class CharacterAgent(ToolCallingAgent):
    def __init__(self, character_json_path: str, **kwargs):
        super().__init__(**kwargs)
        try:
            self.character_json_path = character_json_path
            # validate content of character_json_path
            _ = load_agent_template(TELEGRAM_SYSTEM_PROMPT, Path(self.character_json_path))
        except Exception as e:
            self.logger.log(Text(f"Error validating character file: {e}"), level=LogLevel.ERROR)
            raise e

    async def execute(self, message: Message) -> Message:
        try:
            character_prompt = load_agent_template(TELEGRAM_SYSTEM_PROMPT, Path(self.character_json_path))
            task_message = character_prompt.replace("{{message}}", message.content).replace(
                "{{user_name}}", message.additional_kwargs["author"]
            )
            # Use parent's run method to process the message content
            response = super().run(
                task=task_message,
                stream=False,
                reset=False,  # retain memory
            )

            # Extract message text if response is in JSON format
            response_text = str(response)
            try:
                response_json = json.loads(response_text)
                if isinstance(response_json, dict) and "answer" in response_json:
                    response_text = response_json["answer"]
            except json.JSONDecodeError:
                pass  # Not JSON format, use original response

            return AgentMessage(
                content=response_text,
                conversation_id=message.conversation_id,
            )
        except Exception as e:
            self.logger.log(Text(f"Error processing message: {e}"), level=LogLevel.ERROR)
            return None


================================================
File: /examples/telegram/tools.py
================================================
from galadriel.core_agent import tool
from datetime import datetime


@tool
def get_time(location: str) -> str:
    """
    Get current time in the given location.
    Args:
        location: the location
    """
    return f"The time in {location} is {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"


================================================
File: /examples/telegram/agent.json
================================================
{
  "name": "Elon Musk",
  "settings": {
    "model": "gpt-4",
    "debug": true
  },
  "system": "You are roleplaying as Elon Musk, CEO of Tesla, SpaceX, and X (formerly Twitter). You are known for your ambitious goals in sustainable energy, space exploration, and technological innovation. You have a unique communication style mixing technical depth with memes and humor.",
  "bio": [
    "Entrepreneur focused on accelerating humanity's transition to sustainable energy and making life multi-planetary",
    "Believes in taking bold risks to advance technology and human civilization",
    "Known for controversial statements and unorthodox leadership style"
  ],
  "lore": [
    "Sold PayPal to focus on rockets and electric cars when everyone said it was impossible",
    "Lives in a $50k house despite being one of the world's wealthiest people",
    "Named his child X Ã† A-12",
    "Hosted SNL and revealed he has Asperger's syndrome",
    "Bought Twitter for $44B and renamed it to X"
  ],
  "adjectives": [
    "ambitious",
    "controversial",
    "innovative",
    "workaholic",
    "eccentric",
    "technical",
    "visionary"
  ],
  "topics": [
    "sustainable energy",
    "space exploration",
    "artificial intelligence",
    "electric vehicles",
    "neural technology",
    "social media",
    "cryptocurrency"
  ],
  "style": {
    "all": [
      "mix technical details with humor",
      "use occasional memes",
      "be direct and sometimes controversial",
      "show passion for humanity's future"
    ],
    "chat": [
      "give detailed technical responses",
      "challenge conventional thinking",
      "use analogies to explain complex concepts"
    ],
    "post": [
      "keep it short and punchy",
      "use dry humor",
      "occasionally post memes",
      "make bold statements about the future"
    ]
  },
  "goals_template": [
    "Make life multi-planetary",
    "Accelerate sustainable energy adoption",
    "Develop safe artificial general intelligence",
    "Revolutionize human-computer interfaces",
    "Transform transportation with electric vehicles and tunnels"
  ],
  "facts_template": [
    "Founded SpaceX in 2002",
    "Joined Tesla as chairman in 2004",
    "Became Tesla CEO in 2008",
    "Launched first successful private orbital rocket in 2008",
    "Successfully landed and reused orbital rockets",
    "Created Neuralink to develop brain-computer interfaces",
    "Acquired Twitter in 2022 for $44B"
  ],
  "knowledge": [
    "Rocket engineering and orbital mechanics",
    "Electric vehicle technology and manufacturing",
    "Renewable energy systems and battery technology",
    "Artificial intelligence and its potential risks",
    "Software engineering and internet technology",
    "Physics and engineering principles",
    "Business strategy and scaling operations"
  ],
  "twitter_profile": {
    "username": "elonmusk",
    "screen_name": "Elon Musk",
    "bio": "Mars & Cars, Chips & Dips",
    "nicknames": [
      "Technoking",
      "Space Karen",
      "Dogefather",
      "Chief Twit"
    ]
  },
  "search_queries": {
    "tech_news": [
      "Tesla news",
      "SpaceX launches",
      "AI developments",
      "renewable energy breakthroughs"
    ]
  }
}


================================================
File: /examples/telegram/README.md
================================================
# Telegram Elon Musk Agent Example

A Telegram bot that simulates Elon Musk's personality, capable of interacting with users in a Telegram chat. The bot can provide weather information and tell the current time while maintaining Elon's characteristic communication style.

## Features

- ðŸ¤– Responds to messages in Telegram chats with Elon Musk's personality
- ðŸŒ¤ï¸ Can check weather conditions using the Composio Weather API
- â° Provides current time information
- ðŸ”„ Maintains context and can engage in multi-turn conversations

## Framework Components Used

This example demonstrates several key features of the Galadriel framework:

- `TelegramClient`: Handles Telegram message input/output
- `ToolCallingAgent`: Base agent class for handling tool-based interactions
- `LiteLLMModel`: Integration with language models via LiteLLM
- Custom tools:
  - Composio Weather API (converted using `convert_action`)
  - Time tool

## Setup and Running

1. Install dependencies:

```bash
pip install -r requirements.txt
```

2. Create a `.env` file with the following variables:

```bash
OPENAI_API_KEY=
TELEGRAM_TOKEN=
COMPOSIO_API_KEY=
```

3. Make sure you have the `agent.json` file in the same directory, which defines Elon Musk's personality traits.

4. Run the agent:

```bash
python telegram_agent.py
```


## Telegram Bot Setup

Follow the instructions in this [Telegram Bot Tutorial](https://www.directual.com/lesson-library/how-to-create-a-telegram-bot) to create a new bot and get a token.

================================================
File: /examples/telegram/agent.py
================================================
from galadriel.core_agent import LiteLLMModel
from dotenv import load_dotenv
from pathlib import Path

from galadriel.tools.composio_converter import convert_action
from character_agent import CharacterAgent
from tools import get_time
from galadriel import AgentRuntime
from galadriel.clients import TelegramClient
import os
import asyncio
from galadriel.logging_utils import get_agent_logger

load_dotenv(dotenv_path=Path(".") / ".env", override=True)
model = LiteLLMModel(model_id="gpt-4o", api_key=os.getenv("OPENAI_API_KEY"))

logger = get_agent_logger()

# Set up Telegram client which
# - pushes users' messages to the agent
# - sends agent's responses back to the users
telegram_client = TelegramClient(token=os.getenv("TELEGRAM_TOKEN"), logger=logger)

# Setup Composio weather tool
composio_weather_tool = convert_action(os.getenv("COMPOSIO_API_KEY"), "WEATHERMAP_WEATHER")

# Add agent with GPT-4o model and tools helpful to answer Discord users' questions
elon_musk_agent = CharacterAgent(
    character_json_path="agent.json",
    tools=[composio_weather_tool, get_time],
    model=model,
)

# Set up the runtime
runtime = AgentRuntime(
    inputs=[telegram_client],
    outputs=[telegram_client],
    agent=elon_musk_agent,
)

# Run the agent
asyncio.run(runtime.run())


================================================
File: /examples/multi-agents/README.md
================================================
# Multi-Agent Example

## Description

This example demonstrates a manager-worker pattern using multiple agents. It uses:

- `gpt-4o` model from OpenAI
- A manager `CodeAgent` that coordinates with a specialized worker agent
- A worker agent specialized in web searches using `DuckDuckGoSearchTool`
- `SimpleMessageClient` which implements
  - `AgentInput` to send predefined messages to the agent
  - `AgentOutput` to receive results from the agent and print them
- `AgentRuntime` which connects the client to agent and runs the agent execution

The manager agent can delegate web search tasks to the worker agent, demonstrating how multiple agents can collaborate to accomplish tasks.

## Running the agent

1. Setup local env and install `galadriel`.

```shell
python3 -m venv venv
source venv/bin/activate
pip install galadriel
```

2. Rename `template.env` to `.env` and add your OpenAI API Key.
3. Run the agent.

```shell
python agent.py
```

## Architecture

The example consists of two agents:
- **Manager Agent**: The main agent that receives user queries and coordinates with the worker agent
- **Web Search Agent**: A specialized worker agent equipped with `DuckDuckGoSearchTool` for performing web searches

When a user sends a query, the manager agent can delegate web search tasks to the worker agent when needed, demonstrating hierarchical agent collaboration.

================================================
File: /examples/multi-agents/agent.py
================================================
import asyncio
import os
from pathlib import Path

from dotenv import load_dotenv

from galadriel import AgentRuntime, CodeAgent
from galadriel.clients import SimpleMessageClient
from galadriel.core_agent import LiteLLMModel, DuckDuckGoSearchTool


load_dotenv(dotenv_path=Path(".") / ".env", override=True)
model = LiteLLMModel(model_id="gpt-4o", api_key=os.getenv("OPENAI_API_KEY"))

managed_web_agent = CodeAgent(
    tools=[DuckDuckGoSearchTool()],
    model=model,
    name="web_search",
    description="Runs web searches for you. Give it your query as an argument.",
)

manager_agent = CodeAgent(tools=[], model=model, managed_agents=[managed_web_agent])

# Add basic client which sends two messages to the agent and prints agent's result
client = SimpleMessageClient("What's the most recent of Daige on X (twitter)?")

# Set up the runtime
runtime = AgentRuntime(
    agent=manager_agent,
    inputs=[client],
    outputs=[client],
)

# Run the agent
asyncio.run(runtime.run())


================================================
File: /examples/trading/requirements.txt
================================================
-e ../../. # Install dependencies from pyproject.toml in galadriel

jupiter-python-sdk
solana
solders
gradio


================================================
File: /examples/trading/README.md
================================================
# Trading Agent Example

## Description
This example shows an agent that fetches trending coins, gets market data, does analysis and swaps token.
It uses:
- `gpt-4o` model from OpenAI
- [CodeAgent](https://github.com/galadriel-ai/galadriel/blob/main/galadriel/agent.py) which performs a series of steps until it reaches the final result
- `Cron` which schedules the agent to run at specified intervals.
- `AgentRuntime` which connects the client to agent and runs the agent execution
- `tools` which contains tools that the agent can call to perform specific tasks. For example, `coingecko.fetch_trending_coins` fetches the top trending coins from CoinGecko API. For details on the tools, see the [tools](../../galadriel/tools/) directory.

## How the agent works
- Starts a cron job that runs every 5 minutes.
- Fetches the top trending coins from CoinGecko and Dexscreener APIs.
- Fetches the market data for the specified token.
- Uses the `gpt-4o` model to generate a strategy based on the market data.
    - If the strategy is to buy or sell, it calls the Jupiter or Raydium API to place the order.
    - If the strategy is to hold, it does nothing.

## Running the agent
1. Setup local env and install dependencies.
```shell
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

2. Rename `template.env` to `.env` and add your OpenAI API and Coingecko API keys.
3. Rename `template.agents.env` to `agents.env` and add your solana keypair address.
4. Run the agent.
```shell
python agent.py
```

================================================
File: /examples/trading/.gitignore
================================================
.env


================================================
File: /examples/trading/agent.py
================================================
import asyncio
import os
from pathlib import Path

from dotenv import load_dotenv

from galadriel import AgentRuntime
from galadriel.agent import CodeAgent
from galadriel.core_agent import LiteLLMModel
from galadriel.clients import Cron
from galadriel.tools.web3 import dexscreener, raydium_cpmm
from galadriel.tools.web3 import solana_tools as solana

TRADING_INTERVAL_SECONDS = 300

# Set up a complex trading prompt which explains the trading strategy
TRADING_PROMPT = """
        You are an expert crypto trading advisor. Based on the user's portfolio, current market data, and trading patterns, your task is to suggest one of three actions for each token: Buy, Sell, or Hold. Follow these steps to determine the decision and execute the trade:
        1. Understand the user's position: Evaluate the current holdings of the user (e.g., Alice has 10 SOL).
        2. Analyze market data for each token: Consider the following for decision-making:
           - Price Trends: Evaluate recent price changes (e.g., m5, h1, h6, h24).
           - Volume: Look for significant trading volume changes in the last 24 hours.
           - Liquidity: Assess the token's liquidity to ensure ease of trade.
           - Transaction Trends: Check buy and sell counts to detect market sentiment.
        3. Compare market data with the user's holdings:
           - Recommend Buy if the token shows strong potential (e.g., price dip with high trading volume).
           - Recommend Sell if the price has significantly increased, or there are signs of weakening demand.
           - Recommend Hold if the token's market position is stable or no clear trend is observed.
        4. Based on the analysis, provide a decision for each token in the user's portfolio.
        5. Execute the trade: Use the relevant tools to perform the recommended action (Buy or Sell) for each token.
        """

load_dotenv(dotenv_path=Path(".") / ".env", override=True)
load_dotenv(dotenv_path=Path(".") / ".agents.env", override=True)

model = LiteLLMModel(
    model_id="openai/gpt-4o",
    api_key=os.getenv("OPENAI_API_KEY"),
)

# Prepare a Web3 specific toolkit, relevant for the trading agent
tools = [
    dexscreener.fetch_market_data_devnet,
    raydium_cpmm.BuyTokenWithSolTool(),
    solana.GetAdminWalletAddressTool(),
    solana.get_user_balance,
]

# Create a trading agent
trading_agent = CodeAgent(
    prompt_template=TRADING_PROMPT,
    model=model,
    tools=tools,
    add_base_tools=True,
    additional_authorized_imports=["json"],
    max_steps=8,  # Make the trading agent more reliable by increasing the number of steps he can take to complete the task
)

# Set up the runtime
runtime = AgentRuntime(
    inputs=[Cron(TRADING_INTERVAL_SECONDS)],
    outputs=[],
    agent=trading_agent,
)

# Run the agent
asyncio.run(runtime.run())


================================================
File: /main.py
================================================
import asyncio


async def main():
    pass


if __name__ == "__main__":
    asyncio.run(main())


